[{"content":"Lorsqu\u0026rsquo;on utilise les différents outils de communications habituels de nos jours, il est commun de supposer la garantie de sa vie privée. L\u0026rsquo;utilisateur moyen ne se pose aucune question lorsqu\u0026rsquo;il se connecte à des services comme Facebook, Twitter ou Skype. Ou encore, on se rassure tout de suite à l\u0026rsquo;idée de voir des symboles de \u0026ldquo;sécurité\u0026rdquo; comme le suivant.\nTous les services susmentionnés sont effectivement munis de protections, mais contre et pour qui? Et sous quelle(s) hypothèse(s)? Il s\u0026rsquo;avère que les mesures de sécurité des logiciels communiquant sur les réseaux ne protègent réellement que les entreprises derrière les services associés. La vie privée des individus n\u0026rsquo;est, en majeure partie des cas, pas préservée d\u0026rsquo;aucune manière.\nAfin de bien comprendre pourquoi, prenons un moment pour définir quelques termes et concepts centraux.\nDéfinitions Selon le standard ISO 27000 (2018), on décrit les termes suivant:\n Confidentialité: « propriété selon laquelle l\u0026rsquo;information n\u0026rsquo;est pas rendue disponible ni divulguée à des personnes, des entités ou des processus non autorisés »; Intégrité: « propriété d\u0026rsquo;exactitude et de complétude »; Authentification: « moyen pour une entité d\u0026rsquo;assurer la légitimité d\u0026rsquo;une caractéristique revendiquée .»  La confidentialité est assurée par ce qu\u0026rsquo;on appelle le chiffrement. Ceci correspond plus précisément à une action rendant inintelligible une information par l\u0026rsquo;exécution d\u0026rsquo;un procédé irréversible, nommé chiffre ou méthode de chiffrement, pour quiconque n\u0026rsquo;ayant pas l\u0026rsquo;information nécessaire. L\u0026rsquo;information en question est appelée clef et permet de déchiffrer une donnée chiffrée, c\u0026rsquo;est-à-dire de rendre cette information intelligible à nouveau.\nOn assure ensuite l\u0026rsquo;authenticité d\u0026rsquo;un émetteur ou récepteur par des signatures numériques. Celles-ci peuvent prendre plusieurs formes, comme des codes d\u0026rsquo;authentification de message (CAM) ou des signature de clef privée.\nSécurité par un tiers Le modèle qu\u0026rsquo;on retrouve le plus souvent est celui d\u0026rsquo;une communication où les procédures de sécurisation des communication s\u0026rsquo;effectuent dans un premier temps entre un client et un serveur. Cette approche est représentée dans l\u0026rsquo;image ci-après.\nOn dépeint ici la communication entre le client A et le client B par l\u0026rsquo;intermédiaire du serveur. On remarque, dans un premier temps, que le chiffrement est dès lors opérationnel entre le client A et le serveur. Ceci est représenté par la possession d\u0026rsquo;une clef K_A par A et le serveur ainsi que la flèche verte. Les deux partis de cette communication peuvent donc échanger de manière sûre par ce canal. Idem pour B et le serveur avec la clef K_B.\nCe modèle est celui de multiples services de communication comme: Facebook, Twitter, Skype, Instagram, service de courriel (Outlook, GMail, etc.), \u0026hellip;\nFaille flagrante de ce modèle Il faut rappeler que le diagramme veut représenter un échange entre A et B. Or, lorsque A envoie un message à B, celui-ci passe par le serveur et est protégé, c\u0026rsquo;est-à-dire qu\u0026rsquo;il est chiffré, jusqu'à ce qu\u0026rsquo;il atteigne le serveur. Une fois rendu, le message est déchiffré. Du point de vue de A et de B, il n\u0026rsquo;y a aucun moyen de savoir ce qui se passe sur le serveur avec les messages qui sont transmis au serveur entre le moment où le serveur les reçoit et le moment où il les relaye à son destinataire. En effet, le serveur peut très bien stocker ces messages, les analyser, les propager avec un autre parti, les vendre, etc.\nCe faisant, la sécurité de ce modèle fait une supposition très grave: vous devez être en parfaite confiance avec le fournisseur du service pour que celui-ci ne touche pas à vos données. Dans un monde où les données récoltées de manière massive représentent un capital considérable, il est clair que cette hypothèse devient de plus en plus difficile à faire tenir.\nPourquoi est-ce important? Nombreuses situations suggèrent le caractère sensible de communications comme c\u0026rsquo;est le cas pour certains individus dont la profession demande de garantir la vie privée de soi ou d\u0026rsquo;autrui. On peut penser à des journalistes qui doivent assurer la confidentialité de leur communication, un psychologue qui ne doit pas divulguer d\u0026rsquo;information sur son patient, une personne nécessitant une protection contre les démarches abusives d\u0026rsquo;un état ou un simple civil dont les droits peuvent être abusés au bon moment suite à l\u0026rsquo;accumulation de données sur sa personne.\nIl est facile de s\u0026rsquo;imaginer le danger que cela peut représenter pour une population victime du totalitarisme de leur État. Cependant, il n\u0026rsquo;est pas obligatoire d'être citoyen d\u0026rsquo;un tel État pour s\u0026rsquo;inquiéter. La menace que constitue l\u0026rsquo;accumulation de données sur des individus est bien réel et ce n\u0026rsquo;est pas un hasard si la vie privée est reconnue formellement comme un droit depuis 1947 par la commission des droits de la personne.\nIl est trop facile de se laisser prendre et de considérer que cette faille n\u0026rsquo;est pas assez majeure. Je ne peux pas insister assez sur le fait qu\u0026rsquo;il n’ya aucun moyen de connaître le véritable traitement réservé à nos données dans un tel modèle et que la seule manière d'éviter ce problème est d\u0026rsquo;opter pour une formule différente qui respecte vraiment la vie privée de ses usagers, peu importe ce qu\u0026rsquo;en disent les \u0026ldquo;politiques\u0026rdquo; d\u0026rsquo;utilisation des données affichées par les fournisseurs de service.\nLeur parole n\u0026rsquo;est rien comparativement à l\u0026rsquo;assurance que promet le chiffrement de bout en bout.\nChiffrement de bout en bout Quand on dit «sécurité», on entend l’aptitude d\u0026rsquo;un système à préserver diverses propriétés dont nécessairement la confidentialité, l\u0026rsquo;intégrité et l\u0026rsquo;authentification. Lorsque le système est capable de garantir les propriétés désirées, on dit qu\u0026rsquo;il est sûr. La sûreté de bout en bout est l\u0026rsquo;exigence que les propriétés de sécurité du système soient préservées pour tous ses participants sans l\u0026rsquo;existence d\u0026rsquo;un tiers parti faisant exception et pouvant briser une (ou l\u0026rsquo;ensemble) des propriétés. Autrement dit, un système sûr de bout en bout est un système atteignant toutes les propriétés ci-haut alors que toute entité différente des interlocuteurs d\u0026rsquo;une conversation est envisagée comme des ennemis dans le modèle d\u0026rsquo;adversaire.\nLa figure ci-haut illustre ce phénomène. De façon similaire à la figure précédente, la communication est sécurisée entre A et B, mais le serveur n\u0026rsquo;a aucune connaissance des clefs de chiffrement sur le canal de communication. Ainsi, il peut relayer les données, alors que A et B sont tous deux certains que le serveur (comme tout autre tiers) n\u0026rsquo;a aucune façon d\u0026rsquo;apprendre le contenu des communications entre eux.\nCette formule se prête à un grand nombre d\u0026rsquo;applications, mais nous nous limitons au cas du clavardage afin de fournir des exemples concrets. L\u0026rsquo;exemple par excellence mettant en œuvre ce modèle est Signal.\nSignal «L\u0026rsquo;axolotl, Ambystoma mexicanum, est une espèce de salamandre néoténique faisant partie de l\u0026rsquo;ordre des urodèles et de la famille des Ambystomatidae [\u0026hellip;] Une particularité de cet animal est sa capacité à régénérer des organes endommagés ou détruits.» (Wikipedia)\nCe n\u0026rsquo;est pas un hasard si Signal (son protocole du moins) a eu comme premier nom «Axolotl». Moxie Marlinspike, le créateur de Signal, avait très bien résumé la capacité de son modèle à garantir une autorégénération de la confidentialité de ses utilisateurs au fil du temps d\u0026rsquo;une discussion. La particularité première de Signal est qu\u0026rsquo;il permet de rétablir la confidentialité d\u0026rsquo;une conversation entre deux personnes suivant la fuite d\u0026rsquo;information éventuelle. Ce faisant, comme l\u0026rsquo;axolotl, Signal se guérit à mesure qu\u0026rsquo;il subit des fuites et il le fait avec efficacité dans un contexte asynchrone. C\u0026rsquo;est la raison principale qui fait du protocole de communication de Signal l\u0026rsquo;exemple de ce qui se fait de mieux en matière de communication sûre de bout en bout.\nPour une description détaillée du protocole, référez-vous à mon mémoire (pages 78-82).\nDe mon point de vue, Signal est la meilleure recommandation que je puis faire pour quiconque souhaitant un haut niveau de vie privée. Une caractéristique importante en ce qui a trait à la sécurité est qu\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;un logiciel libre (voir la mise en garde contre les logiciels propriétaires à la fin de cet article).\nPoints faibles Malgré son excellence, Signal souffre tout de même de points faibles non négligeables.\nCouplage avec le téléphone\nEn effet, Signal ne peut fonctionner sans un téléphone intelligent. Bien que l\u0026rsquo;application de bureau Signal existe, il est obligatoire de la lier à une instance installée sur son téléphone mobile. Cela rend donc difficile l\u0026rsquo;utilisation de Signal par certains ne possédant pas téléphone. De plus, comme les appareils mobiles utilisant Android ou iOS ne sont pas formellement sûrs par leur nature propriétaire et puisqu\u0026rsquo;ils ne sont pas conçus en soi pour préserver la vie privée des usagers, il est nécessaire de garantir la sécurité de son appareil mobile afin de jouir des pleines capacités de Signal.\nCommunication de groupe moins sûre que la communication en pair à pair\nEn effet, le protocole de communication n\u0026rsquo;est pas le même lorsque plus d\u0026rsquo;un pair souhaite échanger dans une même conversation sur Signal. Ce faisant, il faut prendre ça en considération si notre priorité est de minimiser les fuites.\nAutres possibilités D\u0026rsquo;autres applications permettent de tirer un haut niveau de sécurité. Certaines ont une étendue d’usages plus variée ou un objectif principal différent, mais servent tout de même la fonction de clavardage.\n  Matrix. Il s\u0026rsquo;agit d\u0026rsquo;un réseau décentralisé plutôt qu\u0026rsquo;une application. Il y a différents moyens de s\u0026rsquo;y connecter comme par Riot. La liste complète des applications compatibles peut se trouver à l\u0026rsquo;adresse suivante:\nhttps://matrix.org/docs/projects/try-matrix-now\nLa documentation pour le protocole pair à pair peut se trouver ici et pour le protocole de groupe, ici. Il s\u0026rsquo;agit d\u0026rsquo;une implémentation des idées de Signal, alors le niveau de sécurité est très semblable s\u0026rsquo;il n\u0026rsquo;est pas identique.\n  WhatsApp et les conversations secrètes de Facebook sont des possibilités. Le lecteur est cependant averti de bien lire la mise en garde ci-après à ce sujet. En particulier, l\u0026rsquo;option de Facebook n\u0026rsquo;est pas optimale dans sa présentation visuelle, ce qui le rend encore moins intéressant.\n  Mise en garde Lorsqu\u0026rsquo;il vient le temps de parler sécurité et de confidentialité, l\u0026rsquo;utilisation de logiciel propriétaire engendre un énorme déclin de confiance sur l\u0026rsquo;effectivité de la garantie de confidentialité. En effet, on ne peut assurer que le logiciel n\u0026rsquo;est pas truffé de code-espion. Bien que le garantir pour une application libre n\u0026rsquo;est toujours pas chose triviale, c\u0026rsquo;est toutefois possible. En résumé, il vaut bien mieux opter pour une solution libre si la confidentialité est le souci principal.\n","description":"","id":7,"section":"cybersécurité","tags":["Chiffrement","Chiffrement de bout en bout","Confidentialité","Signal","WhatsApp","Protocole","Protocole de communication","Communication"],"title":"Comment bien assurer la vie privée du clavardage ?","uri":"https://sim590.github.io/fr/cybers%C3%A9curit%C3%A9/comment-bien-assurer-la-confidentialit%C3%A9-du-clavardage/"},{"content":" L\u0026rsquo;approche de programmation dynamique est souvent associée au remplissage d\u0026rsquo;un tableau à deux dimensions et à l'écriture explicite de ce procédé sous forme itérative. Dans un langage fonctionnel comme Haskell, on bénéficie de quelques avantages d\u0026rsquo;expressivité de haut niveau et de lisibilité qu\u0026rsquo;on ne retrouve pas autrement.\nDans cet article, je commence par explorer deux exemples triviaux de programmation dynamique. Ensuite, je passe sur un problème tout aussi accessible, mais dont l\u0026rsquo;achèvement optimal demandera l\u0026rsquo;utilisation d\u0026rsquo;une structure Data.Array plutôt que la liste conventionnelle.\nÉvaluation paresseuse La particularité principale d\u0026rsquo;Haskell est qu\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;un langage paresseux, c\u0026rsquo;est-à-dire que l'évaluation d\u0026rsquo;une expression ou d\u0026rsquo;une valeur est faite de manière paresseuse. Plus précisément, on peut formuler ce concept par la propriété d\u0026rsquo;un langage à garantir l'évaluation de la valeur d\u0026rsquo;une expression donnée que si celle-ci est bien nécessaire à un calcul subséquent. Par exemple, considérons l\u0026rsquo;expression repeat 0. Cette expression correspond à une liste de taille virtuellement infinie. Cependant, head (repeat 0) correspond à une valeur de taille finie, en l\u0026rsquo;occurence 0. Comme Haskell est paresseux, il ne tente d'évaluer repeat 0 « complètement » que si c\u0026rsquo;est ce qui lui est demandé. Or, en passant repeat 0 en argument à head, on indique à Haskell qu\u0026rsquo;on n\u0026rsquo;est intéressé que par le premier élément, alors la liste repeat 0 ne sera jamais générée au complet, mais seul le premier élément sera calculé.\nDiviser pour régner et calculs en double Lorsqu\u0026rsquo;on souhaite résoudre un problème complexe, il est commun d\u0026rsquo;employer une approche où on réduit un problème à des sous-problèmes permettant ainsi de converger éventuellement en une solution finale. Cette approche s\u0026rsquo;appelle « diviser pour régner » et permet l'écriture de solutions élégantes (voir l\u0026rsquo;algorithme de tri fusion).\nL\u0026rsquo;indicateur premier de la pertinence d\u0026rsquo;investiguer pour une approche de programmation dynamique est celui de l\u0026rsquo;occurrence de calculs faits en double. Comme la méthode « diviser pour régner », l\u0026rsquo;approche de programmation dynamique se base sur un principe de division d\u0026rsquo;un problème en sous-problèmes suivant le principe d\u0026rsquo;optimalité de Bellman:\n Une solution optimale à un problème s\u0026rsquo;obtient en combinant des solutions optimales à des sous-problèmes.\n En d\u0026rsquo;autres termes, pour que le principe s\u0026rsquo;applique, il est nécessaire que la combinaison des solutions aux sous-problèmes soit optimale, lorsque les solutions aux sous-problèmes sont elles-mêmes optimales.\nSuite de Fibonacci 1  import Numeric.Natural   Considérons le problème de déterminer le \\(n^{\\text{ème}}\\) terme de la suite de Fibonacci. La récurrence très connue, définie sur les entiers naturels, est la suivante:\n$$ f(n) = \\begin{cases} 0 \u0026amp; \\text{si}\\ n=0\\\\\n1 \u0026amp; \\text{si}\\ n=1\\\\\nf(n-1) + f(n-2) \u0026amp; \\text{sinon} \\end{cases} $$\nL'écriture de cette fonction, suivant cette relation, est évidente:\n1 2 3 4  fib :: Natural -\u0026gt; Natural fib 0 = 0 fib 1 = 1 fib n = fib (n-1) + fib (n-2)   Cet algorithme est cependant non optimal puisqu\u0026rsquo;il est facile de voir que celui-ci effectue plusieurs calculs en double. Par exemple, pour \\(f(5)\\) on doit calculer \\(f(3)\\) et \\(f(4) = f(2) + f(3)\\). On voit bien qu\u0026rsquo;au moment de calculer \\(f(4)\\), il serait pertinent de récupérer la valeur déjà calculée \\(f(3)\\) afin d'éviter de la recalculer. Malheureusement, l\u0026rsquo;algorithme décrit plus haut ne fait pas cela. Il vaut la peine de noter que plus la valeur de \\(n\\) est élevée, plus le nombre de redondance augmente, ce qui gonfle ainsi la gravité du problème.\nFibonacci: optimisation La programmation dynamique nous permet de régler ce problème. Par exemple, on pourrait écrire la chose suivante:\n1 2 3 4 5  mfib :: Int -\u0026gt; Natural mfib = (map fib [0..] !!) -- (ii) where fib 0 = 0 fib 1 = 1 fib n = mfib (n-2) + mfib (n-1) -- (i)   Le changement apporté au code plus haut devrait être analysé en plusieurs parties. Premièrement, on retrouve la définition de fib qui ressemble pas mal à la première écriture. Cependant, on remarque que la définition du cas général \\((i)\\) ne fait plus directement appel à fib, mais à mfib. Deuxièmement, on remarque que la définition principale de mfib \\((ii)\\) fait un appel à fib. On a donc deux fonctions s\u0026rsquo;appellant en chaîne, ce qui ferme la boucle d\u0026rsquo;appels:\n$$\\texttt{fib} \\rightarrow \\texttt{mfib} \\rightarrow \\texttt{fib} \\rightarrow \\dots$$\nAinsi, le tout correspond à une fonction récurisve convergeant vers les cas de base tout comme c'était le cas dans la première approche. Ceci dit, l\u0026rsquo;entrelacement entre mfib et fib forme justement la différence majeur entre les deux approches. En effet, mfib est défini comme l\u0026rsquo;accès (!!) au \\(n^{\\text{ème}}\\) élément de la liste\n1  map fib [0..] -- (ii)   Cette liste correspond bien sûr à la liste abstraite suivante:\n[fib 0, fib 1, fib 2, ...] \nNotons premièrement que la liste map fib [0..] est une expression correspondant à une liste infinie. Mais comme Haskell est un langage paresseux, seuls les éléments nécessaires au calcul demandé par l\u0026rsquo;appel initial de mfib seront calculés.\nRegardons de plus près ce qui se passe avec un exemple sur mfib 5. Premièrement, l\u0026rsquo;accès au \\(5^\\text{ème}\\) élément de la liste sera demandé, ce qui engendrera l\u0026rsquo;appel à fib 5 qui en retour correspond à mfib 3 et mfib 4. L\u0026rsquo;expression partielle correspondant au calcul demandé initialement est donc mfib 3 + mfib 4. Or, mfib 3 est le \\(3^\\text{ème}\\) élément de la liste \\((ii)\\). On déduit une chose similaire pour mfib 4.\nOn pourrait croire un instant qu\u0026rsquo;Haskell pourrait calculer mfib 3 une fois, le stocker dans le tableau et que, le moment venu, mfib 4 provoque le même calcul, mais il s\u0026rsquo;avère qu\u0026rsquo;Haskell partage la liste \\((ii)\\) entre les différents appels de fib. Ainsi, le premier fil d\u0026rsquo;exécution permettant de calculer fib 3 provoquera l\u0026rsquo;inscription de cette valeur dans la liste afin que les appels subséquents n\u0026rsquo;aient qu'à réutiliser la valeur dans la liste. Il s\u0026rsquo;agit là de la forme la plus évidente et intuitive de l'écriture de cet algorithme sous une approche de programmation dynamique. Autrement, il est possible aussi d'écrire une expression remplissant la même fonction en une ligne:\n1 2  fibs :: [Natural] fibs = 0 : 1 : zipWith (+) fibs (tail fibs)   Cett expression correspond bien sûr à la liste de tous les nombres de Fibonacci. Il suffit maintenant d\u0026rsquo;accéder à l'élément qu\u0026rsquo;on souhaite, par exemple le \\(5^\\text{ème}\\), avec fibs !! 5. Ici encore, on emploie une approche de programmation dynamique puisque la liste est progressivement construite en réutilisant les deux derniers éléments de la liste pour les additionner afin de former le prochain élément ad infinitum.\nNombres triangulaires 1  import Numeric.Natural   Considérons maintenant le problème de générer les nombres triangulaires. On sait que \\(t_n\\), le \\(n^{\\text{ème}}\\) nombre triangulaire, est donné par l\u0026rsquo;expression suivante:\n$$ t_n = \\sum_{i=1}^n i = 1 + 2 + \\dots + n$$\nUne première approche vient rapidement en tête:\n1 2  triangs :: [Natural] triangs = [sum [1..n] | n \u0026lt;- [1..]]   Cependant, cette première approche est absolument affreuse. On refait clairement plusieurs fois les mêmes calculs. On pourrait aussi tirer avantage du fait que \\(t_n\\) trouve l\u0026rsquo;expression équivalente suivante:\n$$ t_n = \\frac{n(n+1)}{2} $$\nAinsi, on pourrait alors écrire:\n1 2  triangs\u0026#39; :: [Natural] triangs\u0026#39; = [n * (n + 1) `div` 2 | n \u0026lt;- [1..]]   Bien que cette stratégie, reposant sur un astuce analytique, apporterait là une amélioration substantielle, cela ne ferait pas de cette approche une voie tout à fait optimale. En effet, on remarque qu\u0026rsquo;on effectue une multiplication, une division et une addition pour chaque élément généré. Il est possible de faire mieux en utilisant la programmation dynamique. De façon similaire à la dernière solution pour Fibonacci, on peut écrire:\n1 2  triangs\u0026#39;\u0026#39; :: [Natural] triangs\u0026#39;\u0026#39; = 1 : zipWith (+) triangs\u0026#39;\u0026#39; [2..]   Ici, on créé encore une fois une liste qui se joint à une seconde liste, la liste infinie [2..], par l\u0026rsquo;addition des éléments de chaque liste deux à deux. On peut développer l\u0026rsquo;expression comme suit:\n1 2 3  1 : zipWith (+) [1,...] [2,3,4...] correspond à [1, 3, ...] 1 : 3 : zipWith (+) [3,...] [3,4,5...] correspond à [1, 3, 6, ...] 1 : 3 : 6 : zipWith (+) [6,...] [4,5,6...] correspond à [1, 3, 6, 10, ...]   Évidemment, une méthode plus intuitive (mais plus verbeuse) est aussi possible.\nSéquences de Collatz 1 2  import Numeric.Natural import Data.Array   Bien que ce prochain problème n\u0026rsquo;est pas d\u0026rsquo;un ordre différent de difficulté, nous allons prendre une avenue qui diffère légèrement afin de garantir encore un rendement optimal.\nUne séquence de Collatz est une séquence de nombres générée suivant un nombre en entrée, appelons cet élément « racine ». Soit $g: \\mathbb{N} \\longrightarrow \\mathbb{N}$ définie comme:\n$$ g(m) = \\begin{cases} \\frac{m}{2} \u0026amp; \\text{si}\\ m\\ \\text{est pair}\\\\\n\\\\ % Nécessaire car autrement, l'équation n\u0026rsquo;arrive pas à se dessiner (trop serré) 3m + 1 \u0026amp; \\text{sinon} \\end{cases} $$\nUne séquence de Collatz, pour une racine \\(r\\), est définie comme la suite\n$$(g(r), (g \\circ g)(r), (g \\circ g \\circ g)(r), \\dots, 1).$$\noù \\(\\circ\\) représente la composition de fonction.\nProblème Pour \\(n \\in \\mathbb{N}\\), on souhaite déterminer la taille de la plus longue séquence de Collatz pour tout \\(1 \\le r \\le n\\).\nUne approche naïve pourrait ressembler à la suivante. Définissons premièrement une fonction calculant la prochaine valeur de la séquence. Appelons la step:\n1 2 3 4 5  step :: Natural -\u0026gt; Natural step 1 = 1 step m | even m = m `div` 2 | otherwise = (3 * m + 1) `div` 2   Remarquons que le cas où \\(m\\) est impair n\u0026rsquo;est plus \\(3m+1\\), mais maintenant \\(\\frac{(3m+1)}{2}\\). Ceci est possible sans perte de généralité puisque si \\(m\\) est impair, alors \\(m=2k+1\\) pour \\(k\\in\\mathbb{N}\\). Ainsi,\n$$ 3m+1 = 3(2k+1)+1 = 2(3k +2) \\quad \\text{est pair}. $$\nCe faisant, le traitement où l\u0026rsquo;argument de step est pair peut tout de suite s\u0026rsquo;appliquer sur l\u0026rsquo;image de \\(3m+1\\). On sauve ainsi une étape à chaque nombre impair rencontré.\nEnsuite, l\u0026rsquo;algorithme bête pour déterminer la longueur d\u0026rsquo;une séquence de Collatz avec pour racine m pourrait ressembler au suivant.\n1 2  dumbSeq :: Natural -\u0026gt; Int dumbSeq m = (+1) $ length $ takeWhile (/=1) $ iterate step m   La lecture est assez directe. On itère sur les appels successifs de step avec comme premier argument m jusqu'à ce qu\u0026rsquo;on tombe sur 1. Ici, iterate créé la liste de tous les résultats d\u0026rsquo;applicaiton de step. On n\u0026rsquo;a donc qu'à prendre la taille de cette liste et additionner 1 (pour compter le nombre 1). Afin de calculer la valeur maximale pour \\(1 \\le r \\le \\text{n}\\), on peut alors calculer comme suit:\n1 2 3  maxDumb :: Natural -\u0026gt; Natural maxDumb 1 = 0 maxDumb n = snd $ maximum $ map (\\ m -\u0026gt; (dumbSeq m, m)) [1..n]   Ici, on créé une liste de paires ordonnées \\((g^i(m), m)\\). On trouve le maximum de cette liste en comparant le premier élément de chaque paire ordonnée (le comportement par défaut de compare tel que défini pour l\u0026rsquo;instance (,) a de la classe Ord).\nClairement, pour \\(n\\) suffisamment grand, le problème peut devenir couteux en temps. On remarque bien sûr que certaines séquences se croisent. Par exemple:\n1 2  r = 3 =\u0026gt; g(3) = g(5) = g(8) = g(4) = g(2) = 1 r = 4 =\u0026gt; g(4) = g(2) = 1   Ce faisant, si on avait à calculer la longueur de la séquence pour \\(g(3)\\) avant \\(g(4)\\), alors le calcul à l\u0026rsquo;itération \\(r=4\\) serait gratuit si nous employions une approche de programmation dynamique.\nSupposons qu\u0026rsquo;on soit intéressé à trouver la réponse pour \\(n\\) très grand. Il serait d\u0026rsquo;abord nécessaire de fixer une taille maximale pour l\u0026rsquo;antémémoire utilisée pour stocker les valeurs déjà calculées. Disons que \\(10^6\\) est raisonnable:\n1 2  bigN :: Natural bigN = 10 ^ (6 :: Natural)   Ensuite, nous définissons la structure seqArray servant d\u0026rsquo;antémémoire ainsi que la routine de comptage des itérations seq' à travers step:\n1 2 3 4 5 6 7 8 9 10  seq\u0026#39; :: Natural -\u0026gt; Natural seq\u0026#39; 1 = 1 seq\u0026#39; i = 1 + next where i\u0026#39; = step i next | i\u0026#39; \u0026gt; bigN = seq\u0026#39; i\u0026#39; | otherwise = seqArray ! i\u0026#39; seqArray :: Array Natural Natural seqArray = listArray bounds\u0026#39; [ seq\u0026#39; i | i \u0026lt;- range bounds\u0026#39;] where bounds\u0026#39; = (1, bigN)   Nous avons grandement avantage ici à utiliser un tableau permettant un accès \\(\\mathcal{O}(1)\\) pour chaque valeur. Bien que c'était autant le cas pour les deux problèmes précédents, nous n\u0026rsquo;avons pas introduit l\u0026rsquo;utilisation de Data.Array jusqu\u0026rsquo;ici afin de simplifier les choses.\nFonctionnement Comme précédemment, remarquons la liaison entre seq' et seqArray. On voit bien que seq' est défini en fonction de seqArray et vice versa. D\u0026rsquo;un côté, on peut le voir comme le fait que seq' utilise les valeurs inscrites dans le tableau afin de faire ses calculs. De l\u0026rsquo;autre côté, on peut interpréter que seqArray n\u0026rsquo;est défini que pour les valeurs que seq' prend. Il y a là une différence majeur avec l'écriture dans un langage impératif comme ceux s\u0026rsquo;apparentant au langage C, par exemple.\nIl n\u0026rsquo;y a aucune exigence à l\u0026rsquo;endroit du programmeur à déterminer les indices admissibles pour indexation dans le tableau. La paresse d\u0026rsquo;Haskell s\u0026rsquo;occupe de tout.\nSéquence de taille maximale Finalement, la fonction suivante évalue la taille maximale d\u0026rsquo;une séquence pour une racine \\(1 \\le r \\le \\texttt{n}\\).\n1 2 3 4  maxSeq :: Natural -\u0026gt; Natural maxSeq 1 = 0 maxSeq n = l where (_, l) = maximum $ map swap $ genericTake n $ assocs seqArray   ","description":"","id":8,"section":"haskell","tags":["Séquence de Collatz","Data.Array","nombre triangulaire"],"title":"Haskell: programmation dynamique","uri":"https://sim590.github.io/fr/haskell/programmation-dynamique/"},{"content":"Je m\u0026rsquo;appelle Simon Désaulniers. Je suis une personne qui œuvre dans mon quotidien en mathématiques et informatique. Je m\u0026rsquo;intéresse à plusieurs sujets comme:\n l\u0026rsquo;algorithmique; les langages informatiques; la sécurité informatique et la cryptographie; les logiciels et outils informatiques; les systèmes distribués; le logiciel libre et respectueux de la vie privée; l\u0026rsquo;algèbre; etc.  Mes intérêts dépassent bien sûr l\u0026rsquo;informatique et les mathématiques. J\u0026rsquo;aime particulièrement les langues, la culture, la musique, la politique et les jeux vidéo.\nLe contenu de mon site Sur ce site, j\u0026rsquo;expose différents concepts, notions ou pratiques sur différents sujets. J\u0026rsquo;aime partager mes découvertes, résolutions de problème et analyses. J\u0026rsquo;espère ainsi permettre à plusieurs d\u0026rsquo;y tirer quelque chose d\u0026rsquo;utile ou du moins intéressant. Je suis un utilisateur de logiciels libres et en particulier de GNU/Linux depuis 2012. Il se peut donc que des sujets en lien avec cela soient exploités.\n","description":"","id":9,"section":"","tags":null,"title":"À propos de moi","uri":"https://sim590.github.io/fr/a-propos/"},{"content":"  GSOC Comme j\u0026rsquo;ai mentionné dans au article antérieur, je participe au programme Google Summer Of Code grâce à l\u0026rsquo;organisation Debian qui supervise mes travaux contribuant au logiciel libre Ring.\nDeux jours restants Il reste deux jours avant mon départ pour le Cape, en Afrique du sud. C\u0026rsquo;est pour assister à l'événement debconf (« Debian conference »), organisé par Debian, que je me rends là. Cet événement est organisé à chaque année et, l\u0026rsquo;année prochaine, c\u0026rsquo;est à Montréal que ça aura lieu !  J\u0026rsquo;ai très hâte de vivre cette expérience qui sera sans doute innoubliable. Debian est une organisation pionière du monde du logiciel libre. Je rencontrerai des gens très dévoués et partageant avec moi beaucoup d\u0026rsquo;intérêts pour le logiciel libre et sa philosophie.\nL\u0026rsquo;Afrique du sud Ce sera la première fois que je prendrai l\u0026rsquo;avion et je ferai une escale à Amsterdam, une ville que j\u0026rsquo;aimerais bien visiter un jour. Ahhhh Jacques Brel.\nJe suis très heureux que le continent d\u0026rsquo;Afrique soit la première destination me permettant de sortir du continent d\u0026rsquo;Amérique pour la première fois. J\u0026rsquo;ai bien hâte de vivre l\u0026rsquo;ambiance du Cape.\nLes requins Y parrait qu\u0026rsquo;y\u0026rsquo;a des requins au Cape.\n","description":"Je m'envole pour le Cape.","id":12,"section":"","tags":null,"title":"Adieu","uri":"https://sim590.github.io/fr/adieu/"},{"content":"Par courriel (sim.desaulniers@gmail.com) ou via LinkedIn.\nL\u0026rsquo;empreinte de ma clef PGP:\n70B9 F71B 74C9 553D 01A1 A0EF 824A 8B97 F97E 4B08  Sinon, vous pouvez simplement utiliser le formulaire suivant:\n","description":"Informations pour me contacter","id":13,"section":"","tags":null,"title":"Contactez-moi","uri":"https://sim590.github.io/fr/contactez-moi/"}]
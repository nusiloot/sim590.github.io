[{"content":"L\u0026rsquo;approche de programmation dynamique est souvent associée au remplissage d\u0026rsquo;un tableau à deux dimensions et à l'écriture explicite de ce procédé sous forme itérative. Dans un langage fonctionnel comme Haskell, on bénéficie de quelques avantages d\u0026rsquo;expressivité de haut niveau et de lisibilité qu\u0026rsquo;on ne retrouve pas autrement.\nDans cet article, je commence par explorer deux exemples triviaux de programmation dynamique. Ensuite, je passe sur un problème tout aussi accessible, mais dont l'écriture\nÉvaluation paresseuse La particularité principale est qu\u0026rsquo;Haskell est un langage paresseux, c\u0026rsquo;est-à-dire que l'évaluation d\u0026rsquo;une expression ou d\u0026rsquo;une valeur est fait de manière paresseuse. Plus précisément, on peut formuler ce concept par la propriété d\u0026rsquo;un langage à garantir l'évaluation de la valeur d\u0026rsquo;une expression donnée que si celle-ci est bien nécessaire à un calcul subséquent. Par exemple, considérons l\u0026rsquo;expression repeat 0. Cette expression correspond à une liste de taille virtuellement infinie. Cependant, head (repeat 0) correspond à une valeur de taille finie, en l\u0026rsquo;occurence 0. Comme Haskell est paresseux, il n'évalue repeat 0 « complètement » que si c\u0026rsquo;est ce qui lui est demandé. Or, en passant repeat 0 en argument à head, on indique à Haskell qu\u0026rsquo;on n\u0026rsquo;est intéressé que par le premier élément, alors la liste repeat 0 ne sera jamais générée au complet, mais seul le premier élément sera calculé.\nDiviser pour régner et calculs en double Lorsqu\u0026rsquo;on souhaite résoudre un problème complexe, il est commun d\u0026rsquo;employer une approche où on réduit un problème à des sous-problèmes permettant ainsi de converger éventuellement en une solution finale. Cette approche s\u0026rsquo;appelle « diviser pour régner » et permet l'écriture de solutions élégantes (voir l\u0026rsquo;algorithme de tri fusion).\nL\u0026rsquo;indicateur premier de la pertinence d\u0026rsquo;investiguer pour une approche de programmation dynamique est celui de l\u0026rsquo;occurrence de calculs faits en double. Comme la méthode « diviser pour régner », l\u0026rsquo;approche de programmation dynamique se base sur un principe de division d\u0026rsquo;un problème en sous-problèmes suivant le principe d\u0026rsquo;optimalité de Bellman:\n Une solution optimale à un problème s\u0026rsquo;obtient en combinant des solutions optimales à des sous-problèmes.\n En d\u0026rsquo;autres termes, pour que le principe s\u0026rsquo;applique, il est nécessaire que la combinaison des solutions aux sous-problèmes soit optimale, lorsque les solutions aux sous-problèmes sont elles-mêmes otpimales.\nSuite de Fibonacci Considérons le problème de déterminer le $n^{\\text{ème}}$ terme de la suite de Fibonacci. La récurrence très connue, définie sur les entiers naturels, est la suivante:\n$$ f(n) = \\begin{cases} 0 \u0026amp; \\text{si}\\ n=0\\\\\n1 \u0026amp; \\text{si}\\ n=1\\\\\nf(n-1) + f(n-2) \u0026amp; \\text{sinon} \\end{cases} $$\nL'écriture de cette fonction, suivant cette relation, est évidente:\n1 2 3 4 5 6  import Numeric.Natural fib :: Natural -\u0026gt; Natural fib 0 = 0 fib 1 = 1 fib n = fib (n-1) + fib (n-2)   Cet algorithme est cependant non optimal puisqu\u0026rsquo;il est facile de voir que celui-ci effectue plusieurs calculs en double. Par exemple, pour $f(5)$ on doit calculer $f(3)$ et $f(4) = f(2) + f(3)$. On voit bien qu\u0026rsquo;au moment de calculer $f(4)$, il serait pertinent de récupérer la valeur déjà calculée $f(3)$ et donc ne pas la calculer encore. Malheureusement, l\u0026rsquo;algorithme décrit plus haut ne fait pas cela. Il vaut la peine de noter que plus la valeur de $n$ est élevée, plus le nombre de redondance augmente, ce qui gonfle ainsi le problème.\nFibonacci: optimisation La programmation dynamique nous permet de régler ce problème. Par exemple, on pourrait écrire la chose suivante:\n1 2 3 4 5 6 7  import Numeric.Natural mfib :: Int -\u0026gt; Natural mfib = (map fib [0..] !!) -- (ii) where fib 0 = 0 fib 1 = 1 fib n = mfib (n-2) + mfib (n-1) -- (i)   Le changement apporté au code plus haut devrait être analysé en plusieurs parties. Premièrement, on retrouve la définition de fib qui ressemble pas mal à la premièrement écriture. Cependant, on remarque que la définition du cas général $(i)$ ne fait plus directement appel à fib, mais à mfib. Deuxièmement, on remarque que la définition principale de mfib $(ii)$ fait un appel à fib. On a donc deux fonctions s\u0026rsquo;appellant en chaîne, ce qui ferme la boucle:\n$$\\texttt{fib} \\rightarrow \\texttt{mfib} \\rightarrow \\texttt{fib} \\rightarrow \\dots$$\nAinsi, le tout correspond à une fonction récurisve convergeant vers les cas de base tout comme c'était le cas dans la première approche. Ceci dit, l\u0026rsquo;entrelacement entre mfib et fib forme justement la différence majeur entre les deux approches. En effet, mfib est défini comme l\u0026rsquo;accès (!!) au $n^{\\text{ème}}$ élément de la liste\n1  map fib [0..] -- (ii)   Cette liste correspond bien sûr à la liste suivante:\n$$(\\texttt{fib 0}, \\texttt{fib 1}, \\texttt{fib 2}, \\dots)$$\nNotons premièrement que la liste map fib [0..] est une expression correspondant à une liste infinie. Mais comme Haskell est un langage paresseux, seuls les éléments nécessaires au calcul demandé par l\u0026rsquo;appel initial de mfib seront calculés.\nRegardons de plus près ce qui se passe avec un exemple sur mfib 5. Premièrement, l\u0026rsquo;accès au $5^\\text{ème}$ élément de la liste sera demandé, ce qui engendrera l\u0026rsquo;appel à fib 5 qui en retour correspond à mfib 3 et mfib 4. L\u0026rsquo;expression partielle correspondant au calcul demandé initialement est donc mfib 3 + mfib 4. Or, mfib 3 est le $3^\\text{ème}$ élément de la liste $(ii)$ et idem pour mfib 4.\nOn pourrait croire un instant qu\u0026rsquo;Haskell pourrait calculer mfib 3 une fois, le stocker dans le tableau et que, le moment venu, mfib 4 provoque le même calcul, mais il s\u0026rsquo;avère qu\u0026rsquo;Haskell partage la liste $(ii)$ entre les différents appels de fib. Ainsi, le premier fil d\u0026rsquo;exécution permettant de calculer fib 3 provoquera l\u0026rsquo;inscription de cette valeur dans la liste afin que les appels subséquents n\u0026rsquo;aient qu'à réutiliser la valeur dans la liste. Il s\u0026rsquo;agit là de la forme la plus évidente et intuitive de l'écriture de cet algorithme sous une approche de programmation dynamique. Autrement, il est possible aussi d'écrire une expression remplissant la même fonction en une ligne:\n1 2 3 4  import Numeric.Natural fibs :: [Natural] fibs = 0 : 1 : zipWith (+) fibs (tail fibs)   Cett expression correspond bien sûr à la liste de tous les nombres de Fibonacci. Il suffit maintenant d\u0026rsquo;accéder à l'élément qu\u0026rsquo;on souhaite, par exemple le $5^\\text{ème}$, avec fibs !! 5. Ici encore, on emploie une approche de programmation dynamique puisque la liste est progressivement construire en réutilisant les deux derniers éléments de la liste pour les additionner afin de former le prochain élément ad infinitum.\nNombres triangulaires Considérons maintenant le problème de générer les nombres triangulaires. On sait que $t_n$, le $n^{\\text{ème}}$ nombre triangulaire, est donné par l\u0026rsquo;expression suivante:\n$$ t_n = \\sum_{i=1}^n i = 1 + 2 + \\dots + n$$\nUne première approche vient rapidement en tête:\n1 2  triangs :: [Natural] triangs = [sum [1..n] | n \u0026lt;- [1..]]   Cependant, cette première approche est clairement affreuse. On refait clairement plusieurs fois les mêmes calculs. On pourrait aussi tirer avantage du fait que $t_n$ trouve l\u0026rsquo;expression équivalente suivante:\n$$ t_n = \\frac{n(n+1)}{2} $$\nAinsi, on pourrait alors écrire:\n1 2  triangs\u0026#39; :: [Natural] triangs\u0026#39; = [n * (n + 1) `div` 2 | n \u0026lt;- [1..]]   Bien que cette stratégie, reposant sur un astuce analytique, apporterait là une amélioration substantielle, cela ne ferait pas de cette approche une voie tout à fait optimale. En effet, on remarque qu\u0026rsquo;on effectue une multiplication, une division et une addition pour chaque élément généré. Il est possible de faire mieux en utilisant la programmation dynamique. De façon similaire à la dernière solution pour Fibonacci, on peut écrire:\n1 2  triangs\u0026#39;\u0026#39; :: [Integer] triangs\u0026#39;\u0026#39; = 1 : zipWith (+) triangs\u0026#39;\u0026#39; [2..]   Ici, on créé encore une fois une liste qui se joint à une seconde liste, la liste [2..], infinie, par l\u0026rsquo;addition des éléments de chaque liste deux à deux. On peut développer l\u0026rsquo;expression comme suit:\n1 2 3  1 : zipWith (+) [1,...] [2,3,4...] -\u0026gt; [1, 3, ...] 1 : 3 : zipWith (+) [3,...] [3,4,5...] -\u0026gt; [1, 3, 6, ...] 1 : 3 : 6 : zipWith (+) [6,...] [4,5,6...] -\u0026gt; [1, 3, 6, 10, ...]   Évidemment, une méthode plus intuitive (mais plus verbeuse) est aussi possible.\nSéquences de Collatz À venir\u0026hellip;\n","description":"","id":7,"section":"haskell","tags":["Séquence de Collatz","Data.Array","nombre triangulaire"],"title":"Haskell: programmation dynamique","uri":"http://sim590.github.io/fr/haskell/programmation-dynamique/"},{"content":"Je m\u0026rsquo;appelle Simon Désaulniers. Je suis une personne qui œuvre dans mon quotidien en mathématiques et informatique. Je m\u0026rsquo;intéresse à plusieurs sujets comme:\n l\u0026rsquo;algorithmique; les langages informatiques; la sécurité informatique et la cryptographie; les logiciels et outils informatiques; les systèmes distribués; le logiciel libre et respectueux de la vie privée; l\u0026rsquo;algèbre; etc.  Mes intérêts dépassent bien sûr l\u0026rsquo;informatique et les mathématiques. J\u0026rsquo;aime particulièrement les langues, la culture, la musique, la politique et les jeux vidéo.\nLe contenu de mon site Sur ce site, j\u0026rsquo;expose différents concepts, notions ou pratiques sur différents sujets. J\u0026rsquo;aime partager mes découvertes, résolutions de problème et analyses. J\u0026rsquo;espère ainsi permettre à plusieurs d\u0026rsquo;y tirer quelque chose d\u0026rsquo;utile ou du moins intéressant. Je suis un utilisateur de logiciels libres et en particulier de GNU/Linux depuis 2012. Il se peut donc que des sujets en lien avec cela soient exploités.\n","description":"","id":8,"section":"","tags":null,"title":"À propos de moi","uri":"http://sim590.github.io/fr/a-propos/"},{"content":"  GSOC Comme j\u0026rsquo;ai mentionné dans au article antérieur, je participe au programme Google Summer Of Code grâce à l\u0026rsquo;organisation Debian qui supervise mes travaux contribuant au logiciel libre Ring.\nDeux jours restants Il reste deux jours avant mon départ pour le Cape, en Afrique du sud. C\u0026rsquo;est pour assister à l'événement debconf (« Debian conference »), organisé par Debian, que je me rends là. Cet événement est organisé à chaque année et, l\u0026rsquo;année prochaine, c\u0026rsquo;est à Montréal que ça aura lieu !  J\u0026rsquo;ai très hâte de vivre cette expérience qui sera sans doute innoubliable. Debian est une organisation pionière du monde du logiciel libre. Je rencontrerai des gens très dévoués et partageant avec moi beaucoup d\u0026rsquo;intérêts pour le logiciel libre et sa philosophie.\nL\u0026rsquo;Afrique du sud Ce sera la première fois que je prendrai l\u0026rsquo;avion et je ferai une escale à Amsterdam, une ville que j\u0026rsquo;aimerais bien visiter un jour. Ahhhh Jacques Brel.\nJe suis très heureux que le continent d\u0026rsquo;Afrique soit la première destination me permettant de sortir du continent d\u0026rsquo;Amérique pour la première fois. J\u0026rsquo;ai bien hâte de vivre l\u0026rsquo;ambiance du Cape.\nLes requins Y parrait qu\u0026rsquo;y\u0026rsquo;a des requins au Cape.\n","description":"Je m'envole pour le Cape.","id":10,"section":"","tags":null,"title":"Adieu","uri":"http://sim590.github.io/fr/adieu/"},{"content":"Par courriel (sim.desaulniers@gmail.com) ou via LinkedIn.\nL\u0026rsquo;empreinte de ma clef PGP:\n70B9 F71B 74C9 553D 01A1 A0EF 824A 8B97 F97E 4B08  Sinon, vous pouvez simplement utiliser le formulaire suivant:\n","description":"Informations pour me contacter","id":11,"section":"","tags":null,"title":"Contactez-moi","uri":"http://sim590.github.io/fr/contactez-moi/"}]
[{"content":"Vim est un éditeur de texte et clairement le meilleur qui soit. Je ne dis pas ça sans peser mes mots. Ceci dit, il ne faut pas lui prêter une identité qu\u0026rsquo;il n\u0026rsquo;a pas. Vim n\u0026rsquo;est pas un environnement de développement intégré (EDI ou IDE en anglais) complet. Cependant, plusieurs aspects à son utilisation font sa grande force pour fournir un EDI complet à son usager:\n un langage de touches permettant aux doigts de faire tout le travail d'édition de texte (couper, effacer, coller, réordonner, formater, etc.). En effet, dans une boîte de texte régulière (comme ce qu\u0026rsquo;on trouve dans les EDIs populaires) la modification de texte, et non la simple écriture, n\u0026rsquo;est pas chose facile. Elle demande souvent l\u0026rsquo;utilisation de la souris, donc la perte de la position des mains déjà en place pour écrire. De plus, cette approche est normalement très lente. Avec Vim, les doigts font le travail. La meilleure comparaison pour comprendre le sentiment est justement celle de l'écriture. On ne pense pas à trouver les touches pour écrire et cela se fait automatiquement. Pour la modification de texte avec Vim, c\u0026rsquo;est la même chose. un langage de script (VimScript) qui lui permet une haute extensibilité; une intégration de l\u0026rsquo;interface système (IS ou le shell en anglais). L\u0026rsquo;utilisation de l\u0026rsquo;IS est entièrement intégrée à travers VimScript ainsi que les différents modes de Vim (Normal, Visual, CMD, etc.). Je ne peux mettre assez l\u0026rsquo;accent sur comment ce trait de Vim est si significatif. Ce faisant, de manière totalement gratuite, un utilisateur de Vim bénéficie déjà des fonctionnalités de l\u0026rsquo;IS dans son éditeur de texte sans avoir recours à l\u0026rsquo;installation très particulière d\u0026rsquo;extension par son EDI. On dit souvent que l\u0026rsquo;IS constitue en réalité l\u0026rsquo;environnement de développement d\u0026rsquo;un utilisateur de Vim. une capacité d\u0026rsquo;intégrer des greffons (plugins en anglais); et une communauté de développeurs très investie dans le partage de code et d\u0026rsquo;outils qui rendent l\u0026rsquo;intégration d\u0026rsquo;outils de développement aisée et facilement personnalisable.  Le tout fait de Vim le choix idéal. Dans ce qui suit, je prends le temps de développer concrètement mon point de vue en m\u0026rsquo;attardant à des préoccupations très importantes de tout développeur, mais selon ma perspective, bien entendu. Je compte donc explorer le mode Normal de Vim, l\u0026rsquo;intégration avec l\u0026rsquo;IS plus en détail, l\u0026rsquo;intégration de GDB (depuis Vim 8) et les différents greffons permettant une sensation d\u0026rsquo;EDI complet.\nN.B: Cet article ne vise pas à vous apprendre les bases de Vim, mais vraiment à convaincre sur le fait qu\u0026rsquo;il constitue un incontournable pour tout développeur.\nLangage de touches Vim comporte plusieurs modes:\n Normal; Insertion (équivalent à une boîte de texte usuelle); Visuel; Visuel en bloc; Ligne de commande (pas de l\u0026rsquo;IS, mais bien de Vim); \u0026hellip;  Le langage de touche est le celui du mode Normal. C\u0026rsquo;est là que s\u0026rsquo;opère la magie des doigts permettant l'édition aisée du texte. Je ne ferai pas un cours complet sur ce mode, mais je vous invite à lire plus amplement sur le sujet. Pour ce faire, référez-vous à la liste de références au bas de cet article.\nAinsi, dans le mode Normal, les touches de l\u0026rsquo;alphabet n\u0026rsquo;insèrent pas simplement les lettres correspondantes, mais exécutent des fonctions élémentaires de Vim. On peut catégoriser ces fonctions en trois (3) types:\n un mouvement: la touche déplace le curseur. une modification: la touche supprime, déplace, coupe ou colle du texte. des fonctions variées\u0026hellip;  Mouvements Afin de se déplacer dans le fichier, on utilise tout le temps le mode normal puisque celui-ci comporte des fonctions très efficaces à cette fin. Voici quelques unes de celles-ci:\n h: déplace le curseur à gauche d\u0026rsquo;une case; j: déplace le curseur sur la ligne inférieure; k: déplace le curseur sur la ligne supérieure; l: déplace le curseur à droite d\u0026rsquo;une case.  Oui, c\u0026rsquo;est bien la raison derrière l\u0026rsquo;icône du poing hjkl comme logo de mon blog. C\u0026rsquo;est en quelque sorte la signature de Vim.\nComme on peut le voir, ces touches remplacent complètement les flèches du clavier. Il y a une raison très pertinente pour motiver l\u0026rsquo;utilisation de ces touches plutôt que les flèches: les mains restent en place là où elles ont besoin d'être afin d\u0026rsquo;utiliser toutes les fonctionnalités de Vim. Voici encore d\u0026rsquo;autres touches de mouvement utiles:\n w: avance le curseur jusqu\u0026rsquo;au début du prochain mot; e: avance le curseur jusqu'à la fin du prochain mot; b: recule le curseur jusqu\u0026rsquo;au début du dernier mot; ge: recule le curseur jusqu'à la fin du dernier mot.  Tous ces mouvements ont leur équivalent pour des gros mots (un mot séparé par des espaces blancs). Il y a donc les touches W, E, B et gE qui exécutent les fonctions correspondantes.\nLa touche f est une touche capitale. Elle est utilisée conjointement avec ; et , afin de naviguer sur les différentes occurrences d\u0026rsquo;une même lettre. On utilise la touche f, qui attend un argument, afin de trouver la prochaine occurrence d\u0026rsquo;une lettre. Dans l\u0026rsquo;exemple ci-haut, f/ déplace le curseur jusqu'à la prochaine occurrence de / sur la ligne. Et si on souhaitait plutôt aller à la seconde ou la troisième occurrence? Eh bien, il suffit de taper la touche ; et le curseur ira à la prochaine occurence. Cette procédure se répète indéfiniment. Si on connait le rang du caractère qu\u0026rsquo;on cherche, disons 4, alors on peut simplement faire 4f/.\nRemarque: Plusieurs commandes prennent des compteurs en préfixe. Par exemple, pour avancer de 10 mots, on pourrait faire 10w.\nBien sûr, il y a plusieurs autres touches de mouvements utiles, mais encore une fois cet article n\u0026rsquo;est pas un tutoriel en soi. Pour une liste exhaustive, référez-vous aux références plus bas. Poursuivons avec les touches de modification du texte.\nModification du texte Ci-après, quelques fonctions de modification de texte qui reviennent souvent:\n d: fonction de suppression. Attend un argument de mouvement; c: fonction de changement (suppression et propulsion dans le mode Insertion). Attend un argument de mouvement; y: copie du texte. Attend un argument de mouvement; p: colle du texte.  Ainsi, on compose les fonctions de mouvement avec les fonctions de modification afin de modifier le texte.\nPar exemple, afin de changer l\u0026rsquo;intérieur d\u0026rsquo;une parenthèse dans une ligne de code comme dans l\u0026rsquo;exemple ci-haut, on procède en tapant sur les touches ci). La touche c est la commande de changement et i) est un mouvement qui signifie à l\u0026rsquo;intérieur de la parenthèse (inside parenthesis en anglais).\nLe point sur le mode normal Il s\u0026rsquo;agit là d\u0026rsquo;une parcelle de tout ce que Vim offre. Une fois mémorisées, ces commandes permettent de propulser la modification de texte de manière considérable.\nBien sûr, je ne mène pas un combat idéologique contre la souris. Celle-ci a son utilité, mais ce n\u0026rsquo;est bien sûr pas dans la modification de texte.\nIntégration de l\u0026rsquo;interface système Par exemple, on peut facilement ordonner les lignes d\u0026rsquo;un fichier en faisant simplement\n1  :%!sort  Ici, c\u0026rsquo;est le programme sort de l\u0026rsquo;IS qui est appelé directement avec en entrée toutes les lignes du fichier (% est un intervalle et signifie tout le fichier) et ! signifie un appel à l\u0026rsquo;IS. Définissons un exemple en appelant seq. Pour ce faire, on écrit :r!seq 10:\n1 2 3 4 5 6 7 8 9 10 Ici :r est un diminutif de :read et permet donc de lire un fichier et l'écrire après le curseur. Dans ce cas-ci, on lit la sortie standard de la commande seq 10 lancé à l\u0026rsquo;IS. On peut alors mêler les nombres avec shuf en écrivant :%!shuf:\n3 10 7 6 1 8 5 2 4 9 Les nombres sont alors placés dans un ordre aléatoire. On peut ordonner le tout avec sort -n. Encore une fois, on écrit :%!sort -n pour obtenir la liste de départ ordonnée.\nUn autre programme très connu de l\u0026rsquo;IS est grep. Eh bien, on peut aisément l\u0026rsquo;utiliser pour affecter le tampon mémoire courant de la même manière que dans l\u0026rsquo;exemple précédent. Disons qu\u0026rsquo;on ait le tampon mémoire suivant:\nLorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. et qu\u0026rsquo;on ne veuille garder que les lignes contenant le sous-mot du, alors on peut simplement écrire %!grep '\\\u0026lt;\\S*du\\S*\\\u0026gt;' pour obtenir:\ntempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, Personnellement, l\u0026rsquo;exemple que je préfère est celui du presse-papier web (ou pastebin). Plusieurs outils en ligne de commande (IS) existent comme pastebinit ou encore dpaste, un programme que j\u0026rsquo;ai moi-même écrit qui fonctionne sur une table de hachage distribuée. Ainsi, afin de partager un fichier sur un presse-papier web, on n\u0026rsquo;a qu'à écrire:\n1  :w !dpaste  et on obtient alors le PIN (ou l\u0026rsquo;URL dans le cas de pastebinit) à partager à quelqu\u0026rsquo;un par notre moyen préféré. Ici, :w est un diminutif de :write qui permet d'écrire le tampon mémoire dans un fichier. En l\u0026rsquo;occurrence, il s\u0026rsquo;agit de l\u0026rsquo;entrée standard de la commande dpaste. On voudra nécessairement copier le PIN (ou l\u0026rsquo;URL) qui sera retourné par le programme. On peut le faire d\u0026rsquo;un coup en utilisant les tubes de l\u0026rsquo;IS:\n1  :w !dpaste | xsel -b  Ici, xsel est un programme lisant son entrée standard et redirigeant celle-ci vers le presse-papier du système.\nIl est important de comprendre que toutes ces notions sont importées directement depuis l\u0026rsquo;interface système, c.-à-d. qu\u0026rsquo;il est suffisant de connaître l\u0026rsquo;IS afin de tirer avantage de ces fonctionnalités dans Vim. Puissant, n\u0026rsquo;est-ce pas?\nGDB Comme l\u0026rsquo;IS est l\u0026rsquo;EDI d\u0026rsquo;un utilisateur de Vim, il est courant d\u0026rsquo;utiliser directement GDB par l\u0026rsquo;intermédiaire d\u0026rsquo;une seconde fenêtre comme l\u0026rsquo;illustre l\u0026rsquo;image ci-après.\nBien que cela fonctionne convenablement, depuis Vim 8, il est maintenant possible d\u0026rsquo;utiliser GDB directement depuis Vim (voir :help :Termdebug). Voici ce à quoi cela ressemble:\nEn plus de fournir un aperçu en direct du débogage dans le tampon mémoire, différentes commandes sont intégrées afin de communiquer directement avec GDB. À ce sujet, si quelqu\u0026rsquo;un s\u0026rsquo;intéresse à obtenir une configuration de touches effective dès, et seulement, lorsque :Termdebug est lancé, voir ma configuration.\nGreffons GDB c\u0026rsquo;est bien pour le débogage, mais qu\u0026rsquo;en est-il de l\u0026rsquo;assistance à l'écriture du code. À cet effet, je propose la découverte de différents greffons que je décris dans le reste de ce billet de blog. En particulier, je survolerai les greffons suivants:\n UltiSnips YouCompletMe Haskell IDE Engine  UltiSnips URL: https://github.com/SirVer/ultisnips\nCe greffon permet de développer des bouts de code prédéfinis (snippet en anglais) dans le tampon mémoire en fonction du type de fichier qu\u0026rsquo;on ouvre. Par exemple, dans un fichier de type cpp, on peut transformer le texte suivant:\n1  main   en le bout de code ci-après:\n1 2 3 4  int main(int argc, char *argv[]) { return 0; }   N.B: Ultisnips ne contient pas de bouts de code par défaut. Il faut donc les écrire soi-même ou utiliser un greffon de bouts de code comme vim-snippets initié par honza. Les bouts de code offerts sur ce dépôt sont nombreux et j\u0026rsquo;invite fortement à utiliser ce greffon en pair avec Ultisnips.\nAnalyseur syntaxique et complétion de mots Un analyseur syntaxique est un composant important d\u0026rsquo;un EDI moderne. En effet, la vitesse à laquelle les analyseurs syntaxiques permettent de communiquer l\u0026rsquo;information sur l\u0026rsquo;exactitude de ce qu'écrit le développeur est un facteur important à considérer. De plus, la complétion des mots est un incontournable dans différents langages où il est coutume d'écrire de longs mots pour décrire les variables ou fonctions du programme.\nÀ la base, Vim prend en charge un outil s\u0026rsquo;apparentant à la complétion de mots. Il s\u0026rsquo;agit de ctags (voir ctags-universal). Ceci dit, cette solution est limitée puisqu\u0026rsquo;elle n\u0026rsquo;effectue pas une analyse du programme comme tel, mais se contente de simplement relever les mots sans tenir compte de la syntaxe. Ces mots sont ensuite stockés dans un fichier qu\u0026rsquo;on doit par la suite fournir à Vim par l\u0026rsquo;option 'tags'. Par exemple, si on un projet avec une structure comme celui-ci:\n1 2 3 4 5 6 7 8 9  . ├── Makefile ├── README └── src ├── interface.cpp ├── interface.h ├── main.cpp ├── tools.cpp └── tools.h   On peut configurer le tout en appelant ctags:\n1  $ ctags -R src/   Ceci génère le fichier tags. Ainsi, on indique finalement à Vim la présence du fichier en configurant l\u0026rsquo;option appropriée: :set tags=./tags.\nBien que cette approche soit limitée, elle est souvent complémentaire lorsqu\u0026rsquo;on cherche à sauter à la définition d\u0026rsquo;un mot (la définition d\u0026rsquo;une fonction par exemple). Les solutions décrites plus bas permettent normalement déjà cela, mais dans les cas où un certain langage n\u0026rsquo;est pas pris en charge par les différents analyseurs syntaxiques décrits plus bas, l\u0026rsquo;utilisation de ctags-universal peut-être appropriée.\nYouCompletMe (C++, Python, Java, Go, Rust, JavaScript, C#, \u0026hellip;) URL: https://github.com/SirVer/ultisnips\nAux grands problèmes, les grandes solutions!\nOui, ce greffon n\u0026rsquo;est pas léger, mais fait un très bon travail. Il prend en charge de nombreux langages (tout dépend de l\u0026rsquo;analyseur syntaxique configuré selon le langage) et s\u0026rsquo;exécute en tâche de fond sans importuner le développeur (depuis Vim 8). Une fois installé et configuré (voir la documentation, FAQ et le wiki), il suffit d\u0026rsquo;ouvrir un fichier source de votre projet afin de se lancer.\nDans le cas de Python, le tout devrait fonctionner directement. Cependant, pour C++, il est nécessaire de faire une étape supplémentaire afin de faire fonctionner YouCompleteMe avec les bons drapeaux de compilation. Pour ce faire, on doit donc ouvrir Vim dans le répertoire du projet (vérifier que :pwd donne bien la racine de votre projet) et lancer :YcmGenerateConfig. Cette commande détectera l\u0026rsquo;outil de compilation utilisé (Makefile par exemple) et lancera la compilation afin de récupérer les drapeaux. Cette étape générera un fichier nommé .ycm_extra_config.py. Le mieux est de placer ce fichier à la racine de votre projet si celui-ci n\u0026rsquo;y apparaît pas à cet endroit directement, une fois généré.\nIl est aussi pertinent de considérer l\u0026rsquo;utilisation d\u0026rsquo;un fichier ~/.ycm_extra_config.py. Comme ce fichier est placé dans votre répertoire personnel ~, il servira de configuration de base au cas où aucun fichier de configuration n\u0026rsquo;est présent dans votre projet ou si vous modifiez un fichier seul. Faites attention à n\u0026rsquo;y inclure que des drapeaux pertinents pour tout fichier de base sans configuration particulière. On pense notamment à des drapeaux comme -std=c++17.\nHIE / LanguageClient (Haskell) URL: https://github.com/haskell/haskell-ide-engine\nPour les amoureux de Haskell, ce programme est un incontournable. Il rend l'écriture beaucoup plus aisée comme c\u0026rsquo;est attendu pour la plupart des langages.\nL\u0026rsquo;utilisateur doit se référer à la page principale du projet afin de trouver toutes les instructions d\u0026rsquo;installation et de configuration.\nRemarque: Afin d\u0026rsquo;installer le tout avec cabal et non pas avec stack comme suggéré sur leur page, il était suffisant de rouler la commande suivante à partir de la racine du dépôt:\n1  $ bash cabal-hie-install hie-8.6.5   Une fois que c\u0026rsquo;est complété, il est obligatoire d\u0026rsquo;ajouter le greffon pour Vim en particulier, il s\u0026rsquo;agit de LanguageClient. Encore une fois, il est nécessaire de suivre les instructions de configurations que je ne liste pas complètement ici.\nAutres greffons Afin d\u0026rsquo;avoir plus d\u0026rsquo;idées de greffons à installer en fonction de vos besoins, je vous suggère de vous référer à ma configuration Vim disponible sur Github. En particulier, vous pouvez consulter la liste de mes greffons ici.\nEn conclusion La particularité première de Vim est sa conception des différents modes d'édition (Normal, Insertion, Visuel, etc.). Ces modes ne s\u0026rsquo;arrêtent vraiment pas à la parcelle que j\u0026rsquo;ai exposée dans cet article. Ils sont vastes. Il y a beaucoup à découvrir. Ce faisant, il n\u0026rsquo;est pas si simple de dire qu\u0026rsquo;on pourrait aussi bien utiliser un greffon pour Visual Studio afin d\u0026rsquo;intégrer Vim car dans la majeure partie des cas, il ne s\u0026rsquo;agit que d\u0026rsquo;un sous-ensemble très restreint de fonctionnalités qui sont incluses dans ce genre de greffon. Ainsi, je préfère largement utiliser Vim avec ses greffons que l\u0026rsquo;inverse susmentionné. C\u0026rsquo;est pourquoi j\u0026rsquo;encourage quiconque à prendre le temps de découvrir Vim.\nLa courbe d\u0026rsquo;apprentissage Comme on dit si bien ces temps-ci, tout est dans l\u0026rsquo;aplatissement de la courbe. ;)\nOui, la courbe est à pic (pas autant que le suggère l\u0026rsquo;image :P), mais elle vaut la peine (comme l\u0026rsquo;indique l\u0026rsquo;image cette fois-ci :P). En travaillant petit à petit, on y arrive.\nRéférences additionnelles Je renvois le lecteur vers les référence suivantes afin qu\u0026rsquo;il en apprenne plus sur Vim:\n vimtutor: sur la ligne de commande (après avoir installé Vim sur votre système). VIM(1): la page de manuel pour Vim (encore une fois après avoir installé Vim). Learn Vim the hard way. Un livre web sur VimScript. Cela donne beaucoup d\u0026rsquo;informations pertinentes sur la structure de Vim et de VimScript. Des viédos tutoriel sur Vim sont disponible sur YouTube à profusion. Il n\u0026rsquo;y a qu'à chercher un peu. Si vous êtes plus du genre à jouer, Vim Adventures est une très bonne option pour débuter.  ","description":"","id":7,"section":"vim","tags":["Vim","hjkl","greffon"],"title":"Vim peut tout faire","uri":"https://sim590.github.io/fr/vim/vim-peut-tout-faire/"},{"content":"Lorsqu\u0026rsquo;on utilise les différents outils de communications habituels de nos jours, il est commun de supposer la garantie de sa vie privée. L\u0026rsquo;utilisateur moyen ne se pose aucune question lorsqu\u0026rsquo;il se connecte à des services comme Facebook, Twitter ou Skype. Ou encore, on se rassure tout de suite à l\u0026rsquo;idée de voir des symboles de \u0026ldquo;sécurité\u0026rdquo; comme le suivant.\nTous les services susmentionnés sont effectivement munis de protections, mais contre et pour qui? Et sous quelle(s) hypothèse(s)? Il s\u0026rsquo;avère que les mesures de sécurité des logiciels communiquant sur les réseaux ne protègent réellement que les entreprises derrière les services associés. La vie privée des individus n\u0026rsquo;est, en majeure partie des cas, pas préservée d\u0026rsquo;aucune manière.\nAfin de bien comprendre pourquoi, prenons un moment pour définir quelques termes et concepts centraux.\nDéfinitions Selon le standard ISO 27000 (2018), on décrit les termes suivant:\n Confidentialité: « propriété selon laquelle l\u0026rsquo;information n\u0026rsquo;est pas rendue disponible ni divulguée à des personnes, des entités ou des processus non autorisés »; Intégrité: « propriété d\u0026rsquo;exactitude et de complétude »; Authentification: « moyen pour une entité d\u0026rsquo;assurer la légitimité d\u0026rsquo;une caractéristique revendiquée .»  La confidentialité est assurée par ce qu\u0026rsquo;on appelle le chiffrement. Ceci correspond plus précisément à une action rendant inintelligible une information par l\u0026rsquo;exécution d\u0026rsquo;un procédé irréversible, nommé chiffre ou méthode de chiffrement, pour quiconque n\u0026rsquo;ayant pas l\u0026rsquo;information nécessaire. L\u0026rsquo;information en question est appelée clef et permet de déchiffrer une donnée chiffrée, c\u0026rsquo;est-à-dire de rendre cette information intelligible à nouveau.\nOn assure ensuite l\u0026rsquo;authenticité d\u0026rsquo;un émetteur ou récepteur par des signatures numériques. Celles-ci peuvent prendre plusieurs formes, comme des codes d\u0026rsquo;authentification de message (CAM) ou des signature de clef privée.\nSécurité par un tiers Le modèle qu\u0026rsquo;on retrouve le plus souvent est celui d\u0026rsquo;une communication où les procédures de sécurisation des communication s\u0026rsquo;effectuent dans un premier temps entre un client et un serveur. Cette approche est représentée dans l\u0026rsquo;image ci-après.\nOn dépeint ici la communication entre le client A et le client B par l\u0026rsquo;intermédiaire du serveur. On remarque, dans un premier temps, que le chiffrement est dès lors opérationnel entre le client A et le serveur. Ceci est représenté par la possession d\u0026rsquo;une clef K_A par A et le serveur ainsi que la flèche verte. Les deux partis de cette communication peuvent donc échanger de manière sûre par ce canal. Idem pour B et le serveur avec la clef K_B.\nCe modèle est celui de multiples services de communication comme: Facebook, Twitter, Skype, Instagram, service de courriel (Outlook, GMail, etc.), \u0026hellip;\nFaille flagrante de ce modèle Il faut rappeler que le diagramme veut représenter un échange entre A et B. Or, lorsque A envoie un message à B, celui-ci passe par le serveur et est protégé, c\u0026rsquo;est-à-dire qu\u0026rsquo;il est chiffré, jusqu'à ce qu\u0026rsquo;il atteigne le serveur. Une fois rendu, le message est déchiffré. Du point de vue de A et de B, il n\u0026rsquo;y a aucun moyen de savoir ce qui se passe sur le serveur avec les messages qui sont transmis au serveur entre le moment où le serveur les reçoit et le moment où il les relaye à son destinataire. En effet, le serveur peut très bien stocker ces messages, les analyser, les propager avec un autre parti, les vendre, etc.\nCe faisant, la sécurité de ce modèle fait une supposition très grave: vous devez être en parfaite confiance avec le fournisseur du service pour que celui-ci ne touche pas à vos données. Dans un monde où les données récoltées de manière massive représentent un capital considérable, il est clair que cette hypothèse devient de plus en plus difficile à faire tenir.\nPourquoi est-ce important? Nombreuses situations suggèrent le caractère sensible de communications comme c\u0026rsquo;est le cas pour certains individus dont la profession demande de garantir la vie privée de soi ou d\u0026rsquo;autrui. On peut penser à des journalistes qui doivent assurer la confidentialité de leur communication, un psychologue qui ne doit pas divulguer d\u0026rsquo;information sur son patient, une personne nécessitant une protection contre les démarches abusives d\u0026rsquo;un état ou un simple civil dont les droits peuvent être abusés au bon moment suite à l\u0026rsquo;accumulation de données sur sa personne.\nIl est facile de s\u0026rsquo;imaginer le danger que cela peut représenter pour une population victime du totalitarisme de leur État. Cependant, il n\u0026rsquo;est pas obligatoire d'être citoyen d\u0026rsquo;un tel État pour s\u0026rsquo;inquiéter. La menace que constitue l\u0026rsquo;accumulation de données sur des individus est bien réel et ce n\u0026rsquo;est pas un hasard si la vie privée est reconnue formellement comme un droit depuis 1947 par la commission des droits de la personne.\nIl est trop facile de se laisser prendre et de considérer que cette faille n\u0026rsquo;est pas assez majeure. Je ne peux pas insister assez sur le fait qu\u0026rsquo;il n’ya aucun moyen de connaître le véritable traitement réservé à nos données dans un tel modèle et que la seule manière d'éviter ce problème est d\u0026rsquo;opter pour une formule différente qui respecte vraiment la vie privée de ses usagers, peu importe ce qu\u0026rsquo;en disent les \u0026ldquo;politiques\u0026rdquo; d\u0026rsquo;utilisation des données affichées par les fournisseurs de service.\nLeur parole n\u0026rsquo;est rien comparativement à l\u0026rsquo;assurance que promet le chiffrement de bout en bout.\nChiffrement de bout en bout Quand on dit «sécurité», on entend l’aptitude d\u0026rsquo;un système à préserver diverses propriétés dont nécessairement la confidentialité, l\u0026rsquo;intégrité et l\u0026rsquo;authentification. Lorsque le système est capable de garantir les propriétés désirées, on dit qu\u0026rsquo;il est sûr. La sûreté de bout en bout est l\u0026rsquo;exigence que les propriétés de sécurité du système soient préservées pour tous ses participants sans l\u0026rsquo;existence d\u0026rsquo;un tiers parti faisant exception et pouvant briser une (ou l\u0026rsquo;ensemble) des propriétés. Autrement dit, un système sûr de bout en bout est un système atteignant toutes les propriétés ci-haut alors que toute entité différente des interlocuteurs d\u0026rsquo;une conversation est envisagée comme des ennemis dans le modèle d\u0026rsquo;adversaire.\nLa figure ci-haut illustre ce phénomène. De façon similaire à la figure précédente, la communication est sécurisée entre A et B, mais le serveur n\u0026rsquo;a aucune connaissance des clefs de chiffrement sur le canal de communication. Ainsi, il peut relayer les données, alors que A et B sont tous deux certains que le serveur (comme tout autre tiers) n\u0026rsquo;a aucune façon d\u0026rsquo;apprendre le contenu des communications entre eux.\nCette formule se prête à un grand nombre d\u0026rsquo;applications, mais nous nous limitons au cas du clavardage afin de fournir des exemples concrets. L\u0026rsquo;exemple par excellence mettant en œuvre ce modèle est Signal.\nSignal «L\u0026rsquo;axolotl, Ambystoma mexicanum, est une espèce de salamandre néoténique faisant partie de l\u0026rsquo;ordre des urodèles et de la famille des Ambystomatidae [\u0026hellip;] Une particularité de cet animal est sa capacité à régénérer des organes endommagés ou détruits.» (Wikipedia)\nCe n\u0026rsquo;est pas un hasard si Signal (son protocole du moins) a eu comme premier nom «Axolotl». Moxie Marlinspike, le créateur de Signal, avait très bien résumé la capacité de son modèle à garantir une autorégénération de la confidentialité de ses utilisateurs au fil du temps d\u0026rsquo;une discussion. La particularité première de Signal est qu\u0026rsquo;il permet de rétablir la confidentialité d\u0026rsquo;une conversation entre deux personnes suivant la fuite d\u0026rsquo;information éventuelle. Ce faisant, comme l\u0026rsquo;axolotl, Signal se guérit à mesure qu\u0026rsquo;il subit des fuites et il le fait avec efficacité dans un contexte asynchrone. C\u0026rsquo;est la raison principale qui fait du protocole de communication de Signal l\u0026rsquo;exemple de ce qui se fait de mieux en matière de communication sûre de bout en bout.\nPour une description détaillée du protocole, référez-vous à mon mémoire (pages 78-82).\nDe mon point de vue, Signal est la meilleure recommandation que je puis faire pour quiconque souhaitant un haut niveau de vie privée. Une caractéristique importante en ce qui a trait à la sécurité est qu\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;un logiciel libre (voir la mise en garde contre les logiciels propriétaires à la fin de cet article).\nPoints faibles Malgré son excellence, Signal souffre tout de même de points faibles non négligeables.\nCouplage avec le téléphone\nEn effet, Signal ne peut fonctionner sans un téléphone intelligent. Bien que l\u0026rsquo;application de bureau Signal existe, il est obligatoire de la lier à une instance installée sur son téléphone mobile. Cela rend donc difficile l\u0026rsquo;utilisation de Signal par certains ne possédant pas téléphone. De plus, comme les appareils mobiles utilisant Android ou iOS ne sont pas formellement sûrs par leur nature propriétaire et puisqu\u0026rsquo;ils ne sont pas conçus en soi pour préserver la vie privée des usagers, il est nécessaire de garantir la sécurité de son appareil mobile afin de jouir des pleines capacités de Signal.\nCommunication de groupe moins sûre que la communication en pair à pair\nEn effet, le protocole de communication n\u0026rsquo;est pas le même lorsque plus d\u0026rsquo;un pair souhaite échanger dans une même conversation sur Signal. Ce faisant, il faut prendre ça en considération si notre priorité est de minimiser les fuites.\nAutres possibilités D\u0026rsquo;autres applications permettent de tirer un haut niveau de sécurité. Certaines ont une étendue d’usages plus variée ou un objectif principal différent, mais servent tout de même la fonction de clavardage.\n  Matrix. Il s\u0026rsquo;agit d\u0026rsquo;un réseau décentralisé plutôt qu\u0026rsquo;une application. Il y a différents moyens de s\u0026rsquo;y connecter comme par Riot. La liste complète des applications compatibles peut se trouver à l\u0026rsquo;adresse suivante:\nhttps://matrix.org/docs/projects/try-matrix-now\nLa documentation pour le protocole pair à pair peut se trouver ici et pour le protocole de groupe, ici. Il s\u0026rsquo;agit d\u0026rsquo;une implémentation des idées de Signal, alors le niveau de sécurité est très semblable s\u0026rsquo;il n\u0026rsquo;est pas identique.\n  WhatsApp et les conversations secrètes de Facebook sont des possibilités. Le lecteur est cependant averti de bien lire la mise en garde ci-après à ce sujet. En particulier, l\u0026rsquo;option de Facebook n\u0026rsquo;est pas optimale dans sa présentation visuelle, ce qui le rend encore moins intéressant.\n  Mise en garde Lorsqu\u0026rsquo;il vient le temps de parler sécurité et de confidentialité, l\u0026rsquo;utilisation de logiciel propriétaire engendre un énorme déclin de confiance sur l\u0026rsquo;effectivité de la garantie de confidentialité. En effet, on ne peut assurer que le logiciel n\u0026rsquo;est pas truffé de code-espion. Bien que le garantir pour une application libre n\u0026rsquo;est toujours pas chose triviale, c\u0026rsquo;est toutefois possible. En résumé, il vaut bien mieux opter pour une solution libre si la confidentialité est le souci principal.\n","description":"","id":8,"section":"cybersécurité","tags":["Chiffrement","Chiffrement de bout en bout","Confidentialité","Signal","WhatsApp","Protocole","Protocole de communication","Communication"],"title":"Comment bien assurer la vie privée du clavardage?","uri":"https://sim590.github.io/fr/cybers%C3%A9curit%C3%A9/comment-bien-assurer-la-confidentialit%C3%A9-du-clavardage/"},{"content":" L\u0026rsquo;approche de programmation dynamique est souvent associée au remplissage d\u0026rsquo;un tableau à deux dimensions et à l'écriture explicite de ce procédé sous forme itérative. Dans un langage fonctionnel comme Haskell, on bénéficie de quelques avantages d\u0026rsquo;expressivité de haut niveau et de lisibilité qu\u0026rsquo;on ne retrouve pas autrement.\nDans cet article, je commence par explorer deux exemples triviaux de programmation dynamique. Ensuite, je passe sur un problème tout aussi accessible, mais dont l\u0026rsquo;achèvement optimal demandera l\u0026rsquo;utilisation d\u0026rsquo;une structure Data.Array plutôt que la liste conventionnelle.\nÉvaluation paresseuse La particularité principale d\u0026rsquo;Haskell est qu\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;un langage paresseux, c\u0026rsquo;est-à-dire que l'évaluation d\u0026rsquo;une expression ou d\u0026rsquo;une valeur est faite de manière paresseuse. Plus précisément, on peut formuler ce concept par la propriété d\u0026rsquo;un langage à garantir l'évaluation de la valeur d\u0026rsquo;une expression donnée que si celle-ci est bien nécessaire à un calcul subséquent. Par exemple, considérons l\u0026rsquo;expression repeat 0. Cette expression correspond à une liste de taille virtuellement infinie. Cependant, head (repeat 0) correspond à une valeur de taille finie, en l\u0026rsquo;occurence 0. Comme Haskell est paresseux, il ne tente d'évaluer repeat 0 « complètement » que si c\u0026rsquo;est ce qui lui est demandé. Or, en passant repeat 0 en argument à head, on indique à Haskell qu\u0026rsquo;on n\u0026rsquo;est intéressé que par le premier élément, alors la liste repeat 0 ne sera jamais générée au complet, mais seul le premier élément sera calculé.\nDiviser pour régner et calculs en double Lorsqu\u0026rsquo;on souhaite résoudre un problème complexe, il est commun d\u0026rsquo;employer une approche où on réduit un problème à des sous-problèmes permettant ainsi de converger éventuellement en une solution finale. Cette approche s\u0026rsquo;appelle « diviser pour régner » et permet l'écriture de solutions élégantes (voir l\u0026rsquo;algorithme de tri fusion).\nL\u0026rsquo;indicateur premier de la pertinence d\u0026rsquo;investiguer pour une approche de programmation dynamique est celui de l\u0026rsquo;occurrence de calculs faits en double. Comme la méthode « diviser pour régner », l\u0026rsquo;approche de programmation dynamique se base sur un principe de division d\u0026rsquo;un problème en sous-problèmes suivant le principe d\u0026rsquo;optimalité de Bellman:\n Une solution optimale à un problème s\u0026rsquo;obtient en combinant des solutions optimales à des sous-problèmes.\n En d\u0026rsquo;autres termes, pour que le principe s\u0026rsquo;applique, il est nécessaire que la combinaison des solutions aux sous-problèmes soit optimale, lorsque les solutions aux sous-problèmes sont elles-mêmes optimales.\nSuite de Fibonacci 1  import Numeric.Natural   Considérons le problème de déterminer le \\(n^{\\text{ème}}\\) terme de la suite de Fibonacci. La récurrence très connue, définie sur les entiers naturels, est la suivante:\n$$ f(n) = \\begin{cases} 0 \u0026amp; \\text{si}\\ n=0\\\\\n1 \u0026amp; \\text{si}\\ n=1\\\\\nf(n-1) + f(n-2) \u0026amp; \\text{sinon} \\end{cases} $$\nL'écriture de cette fonction, suivant cette relation, est évidente:\n1 2 3 4  fib :: Natural -\u0026gt; Natural fib 0 = 0 fib 1 = 1 fib n = fib (n-1) + fib (n-2)   Cet algorithme est cependant non optimal puisqu\u0026rsquo;il est facile de voir que celui-ci effectue plusieurs calculs en double. Par exemple, pour \\(f(5)\\) on doit calculer \\(f(3)\\) et \\(f(4) = f(2) + f(3)\\). On voit bien qu\u0026rsquo;au moment de calculer \\(f(4)\\), il serait pertinent de récupérer la valeur déjà calculée \\(f(3)\\) afin d'éviter de la recalculer. Malheureusement, l\u0026rsquo;algorithme décrit plus haut ne fait pas cela. Il vaut la peine de noter que plus la valeur de \\(n\\) est élevée, plus le nombre de redondance augmente, ce qui gonfle ainsi la gravité du problème.\nFibonacci: optimisation La programmation dynamique nous permet de régler ce problème. Par exemple, on pourrait écrire la chose suivante:\n1 2 3 4 5  mfib :: Int -\u0026gt; Natural mfib = (map fib [0..] !!) -- (ii) where fib 0 = 0 fib 1 = 1 fib n = mfib (n-2) + mfib (n-1) -- (i)   Le changement apporté au code plus haut devrait être analysé en plusieurs parties. Premièrement, on retrouve la définition de fib qui ressemble pas mal à la première écriture. Cependant, on remarque que la définition du cas général \\((i)\\) ne fait plus directement appel à fib, mais à mfib. Deuxièmement, on remarque que la définition principale de mfib \\((ii)\\) fait un appel à fib. On a donc deux fonctions s\u0026rsquo;appellant en chaîne, ce qui ferme la boucle d\u0026rsquo;appels:\n$$\\texttt{fib} \\rightarrow \\texttt{mfib} \\rightarrow \\texttt{fib} \\rightarrow \\dots$$\nAinsi, le tout correspond à une fonction récurisve convergeant vers les cas de base tout comme c'était le cas dans la première approche. Ceci dit, l\u0026rsquo;entrelacement entre mfib et fib forme justement la différence majeur entre les deux approches. En effet, mfib est défini comme l\u0026rsquo;accès (!!) au \\(n^{\\text{ème}}\\) élément de la liste\n1  map fib [0..] -- (ii)   Cette liste correspond bien sûr à la liste abstraite suivante:\n[fib 0, fib 1, fib 2, ...] \nNotons premièrement que la liste map fib [0..] est une expression correspondant à une liste infinie. Mais comme Haskell est un langage paresseux, seuls les éléments nécessaires au calcul demandé par l\u0026rsquo;appel initial de mfib seront calculés.\nRegardons de plus près ce qui se passe avec un exemple sur mfib 5. Premièrement, l\u0026rsquo;accès au \\(5^\\text{ème}\\) élément de la liste sera demandé, ce qui engendrera l\u0026rsquo;appel à fib 5 qui en retour correspond à mfib 3 et mfib 4. L\u0026rsquo;expression partielle correspondant au calcul demandé initialement est donc mfib 3 + mfib 4. Or, mfib 3 est le \\(3^\\text{ème}\\) élément de la liste \\((ii)\\). On déduit une chose similaire pour mfib 4.\nOn pourrait croire un instant qu\u0026rsquo;Haskell pourrait calculer mfib 3 une fois, le stocker dans le tableau et que, le moment venu, mfib 4 provoque le même calcul, mais il s\u0026rsquo;avère qu\u0026rsquo;Haskell partage la liste \\((ii)\\) entre les différents appels de fib. Ainsi, le premier fil d\u0026rsquo;exécution permettant de calculer fib 3 provoquera l\u0026rsquo;inscription de cette valeur dans la liste afin que les appels subséquents n\u0026rsquo;aient qu'à réutiliser la valeur dans la liste. Il s\u0026rsquo;agit là de la forme la plus évidente et intuitive de l'écriture de cet algorithme sous une approche de programmation dynamique. Autrement, il est possible aussi d'écrire une expression remplissant la même fonction en une ligne:\n1 2  fibs :: [Natural] fibs = 0 : 1 : zipWith (+) fibs (tail fibs)   Cett expression correspond bien sûr à la liste de tous les nombres de Fibonacci. Il suffit maintenant d\u0026rsquo;accéder à l'élément qu\u0026rsquo;on souhaite, par exemple le \\(5^\\text{ème}\\), avec fibs !! 5. Ici encore, on emploie une approche de programmation dynamique puisque la liste est progressivement construite en réutilisant les deux derniers éléments de la liste pour les additionner afin de former le prochain élément ad infinitum.\nNombres triangulaires 1  import Numeric.Natural   Considérons maintenant le problème de générer les nombres triangulaires. On sait que \\(t_n\\), le \\(n^{\\text{ème}}\\) nombre triangulaire, est donné par l\u0026rsquo;expression suivante:\n$$ t_n = \\sum_{i=1}^n i = 1 + 2 + \\dots + n$$\nUne première approche vient rapidement en tête:\n1 2  triangs :: [Natural] triangs = [sum [1..n] | n \u0026lt;- [1..]]   Cependant, cette première approche est absolument affreuse. On refait clairement plusieurs fois les mêmes calculs. On pourrait aussi tirer avantage du fait que \\(t_n\\) trouve l\u0026rsquo;expression équivalente suivante:\n$$ t_n = \\frac{n(n+1)}{2} $$\nAinsi, on pourrait alors écrire:\n1 2  triangs\u0026#39; :: [Natural] triangs\u0026#39; = [n * (n + 1) `div` 2 | n \u0026lt;- [1..]]   Bien que cette stratégie, reposant sur un astuce analytique, apporterait là une amélioration substantielle, cela ne ferait pas de cette approche une voie tout à fait optimale. En effet, on remarque qu\u0026rsquo;on effectue une multiplication, une division et une addition pour chaque élément généré. Il est possible de faire mieux en utilisant la programmation dynamique. De façon similaire à la dernière solution pour Fibonacci, on peut écrire:\n1 2  triangs\u0026#39;\u0026#39; :: [Natural] triangs\u0026#39;\u0026#39; = 1 : zipWith (+) triangs\u0026#39;\u0026#39; [2..]   Ici, on créé encore une fois une liste qui se joint à une seconde liste, la liste infinie [2..], par l\u0026rsquo;addition des éléments de chaque liste deux à deux. On peut développer l\u0026rsquo;expression comme suit:\n1 2 3  1 : zipWith (+) [1,...] [2,3,4...] correspond à [1, 3, ...] 1 : 3 : zipWith (+) [3,...] [3,4,5...] correspond à [1, 3, 6, ...] 1 : 3 : 6 : zipWith (+) [6,...] [4,5,6...] correspond à [1, 3, 6, 10, ...]   Évidemment, une méthode plus intuitive (mais plus verbeuse) est aussi possible.\nSéquences de Collatz 1 2  import Numeric.Natural import Data.Array   Bien que ce prochain problème n\u0026rsquo;est pas d\u0026rsquo;un ordre différent de difficulté, nous allons prendre une avenue qui diffère légèrement afin de garantir encore un rendement optimal.\nUne séquence de Collatz est une séquence de nombres générée suivant un nombre en entrée, appelons cet élément « racine ». Soit $g: \\mathbb{N} \\longrightarrow \\mathbb{N}$ définie comme:\n$$ g(m) = \\begin{cases} \\frac{m}{2} \u0026amp; \\text{si}\\ m\\ \\text{est pair}\\\\\n\\\\ % Nécessaire car autrement, l'équation n\u0026rsquo;arrive pas à se dessiner (trop serré) 3m + 1 \u0026amp; \\text{sinon} \\end{cases} $$\nUne séquence de Collatz, pour une racine \\(r\\), est définie comme la suite\n$$(g(r), (g \\circ g)(r), (g \\circ g \\circ g)(r), \\dots, 1).$$\noù \\(\\circ\\) représente la composition de fonction.\nProblème Pour \\(n \\in \\mathbb{N}\\), on souhaite déterminer la taille de la plus longue séquence de Collatz pour tout \\(1 \\le r \\le n\\).\nUne approche naïve pourrait ressembler à la suivante. Définissons premièrement une fonction calculant la prochaine valeur de la séquence. Appelons la step:\n1 2 3 4 5  step :: Natural -\u0026gt; Natural step 1 = 1 step m | even m = m `div` 2 | otherwise = (3 * m + 1) `div` 2   Remarquons que le cas où \\(m\\) est impair n\u0026rsquo;est plus \\(3m+1\\), mais maintenant \\(\\frac{(3m+1)}{2}\\). Ceci est possible sans perte de généralité puisque si \\(m\\) est impair, alors \\(m=2k+1\\) pour \\(k\\in\\mathbb{N}\\). Ainsi,\n$$ 3m+1 = 3(2k+1)+1 = 2(3k +2) \\quad \\text{est pair}. $$\nCe faisant, le traitement où l\u0026rsquo;argument de step est pair peut tout de suite s\u0026rsquo;appliquer sur l\u0026rsquo;image de \\(3m+1\\). On sauve ainsi une étape à chaque nombre impair rencontré.\nEnsuite, l\u0026rsquo;algorithme bête pour déterminer la longueur d\u0026rsquo;une séquence de Collatz avec pour racine m pourrait ressembler au suivant.\n1 2  dumbSeq :: Natural -\u0026gt; Int dumbSeq m = (+1) $ length $ takeWhile (/=1) $ iterate step m   La lecture est assez directe. On itère sur les appels successifs de step avec comme premier argument m jusqu'à ce qu\u0026rsquo;on tombe sur 1. Ici, iterate créé la liste de tous les résultats d\u0026rsquo;applicaiton de step. On n\u0026rsquo;a donc qu'à prendre la taille de cette liste et additionner 1 (pour compter le nombre 1). Afin de calculer la valeur maximale pour \\(1 \\le r \\le \\text{n}\\), on peut alors calculer comme suit:\n1 2 3  maxDumb :: Natural -\u0026gt; Natural maxDumb 1 = 0 maxDumb n = snd $ maximum $ map (\\ m -\u0026gt; (dumbSeq m, m)) [1..n]   Ici, on créé une liste de paires ordonnées \\((g^i(m), m)\\). On trouve le maximum de cette liste en comparant le premier élément de chaque paire ordonnée (le comportement par défaut de compare tel que défini pour l\u0026rsquo;instance (,) a de la classe Ord).\nClairement, pour \\(n\\) suffisamment grand, le problème peut devenir couteux en temps. On remarque bien sûr que certaines séquences se croisent. Par exemple:\n1 2  r = 3 =\u0026gt; g(3) = g(5) = g(8) = g(4) = g(2) = 1 r = 4 =\u0026gt; g(4) = g(2) = 1   Ce faisant, si on avait à calculer la longueur de la séquence pour \\(g(3)\\) avant \\(g(4)\\), alors le calcul à l\u0026rsquo;itération \\(r=4\\) serait gratuit si nous employions une approche de programmation dynamique.\nSupposons qu\u0026rsquo;on soit intéressé à trouver la réponse pour \\(n\\) très grand. Il serait d\u0026rsquo;abord nécessaire de fixer une taille maximale pour l\u0026rsquo;antémémoire utilisée pour stocker les valeurs déjà calculées. Disons que \\(10^6\\) est raisonnable:\n1 2  bigN :: Natural bigN = 10 ^ (6 :: Natural)   Ensuite, nous définissons la structure seqArray servant d\u0026rsquo;antémémoire ainsi que la routine de comptage des itérations seq' à travers step:\n1 2 3 4 5 6 7 8 9 10  seq\u0026#39; :: Natural -\u0026gt; Natural seq\u0026#39; 1 = 1 seq\u0026#39; i = 1 + next where i\u0026#39; = step i next | i\u0026#39; \u0026gt; bigN = seq\u0026#39; i\u0026#39; | otherwise = seqArray ! i\u0026#39; seqArray :: Array Natural Natural seqArray = listArray bounds\u0026#39; [ seq\u0026#39; i | i \u0026lt;- range bounds\u0026#39;] where bounds\u0026#39; = (1, bigN)   Nous avons grandement avantage ici à utiliser un tableau permettant un accès \\(\\mathcal{O}(1)\\) pour chaque valeur. Bien que c'était autant le cas pour les deux problèmes précédents, nous n\u0026rsquo;avons pas introduit l\u0026rsquo;utilisation de Data.Array jusqu\u0026rsquo;ici afin de simplifier les choses.\nFonctionnement Comme précédemment, remarquons la liaison entre seq' et seqArray. On voit bien que seq' est défini en fonction de seqArray et vice versa. D\u0026rsquo;un côté, on peut le voir comme le fait que seq' utilise les valeurs inscrites dans le tableau afin de faire ses calculs. De l\u0026rsquo;autre côté, on peut interpréter que seqArray n\u0026rsquo;est défini que pour les valeurs que seq' prend. Il y a là une différence majeur avec l'écriture dans un langage impératif comme ceux s\u0026rsquo;apparentant au langage C, par exemple.\nIl n\u0026rsquo;y a aucune exigence à l\u0026rsquo;endroit du programmeur à déterminer les indices admissibles pour indexation dans le tableau. La paresse d\u0026rsquo;Haskell s\u0026rsquo;occupe de tout.\nSéquence de taille maximale Finalement, la fonction suivante évalue la taille maximale d\u0026rsquo;une séquence pour une racine \\(1 \\le r \\le \\texttt{n}\\).\n1 2 3 4  maxSeq :: Natural -\u0026gt; Natural maxSeq 1 = 0 maxSeq n = l where (_, l) = maximum $ map swap $ genericTake n $ assocs seqArray   ","description":"","id":9,"section":"haskell","tags":["Séquence de Collatz","Data.Array","nombre triangulaire"],"title":"Haskell: programmation dynamique","uri":"https://sim590.github.io/fr/haskell/programmation-dynamique/"},{"content":"Je m\u0026rsquo;appelle Simon Désaulniers. Je suis une personne qui œuvre dans mon quotidien en mathématiques et informatique. Je m\u0026rsquo;intéresse à plusieurs sujets comme:\n l\u0026rsquo;algorithmique; les langages informatiques; la sécurité informatique et la cryptographie; les logiciels et outils informatiques; les systèmes distribués; le logiciel libre et respectueux de la vie privée; l\u0026rsquo;algèbre; etc.  Mes intérêts dépassent bien sûr l\u0026rsquo;informatique et les mathématiques. J\u0026rsquo;aime particulièrement les langues, la culture, la musique, la politique et les jeux vidéo.\nLe contenu de mon site Sur ce site, j\u0026rsquo;expose différents concepts, notions ou pratiques sur différents sujets. J\u0026rsquo;aime partager mes découvertes, résolutions de problème et analyses. J\u0026rsquo;espère ainsi permettre à plusieurs d\u0026rsquo;y tirer quelque chose d\u0026rsquo;utile ou du moins intéressant. Je suis un utilisateur de logiciels libres et en particulier de GNU/Linux depuis 2012. Il se peut donc que des sujets en lien avec cela soient exploités.\n","description":"","id":10,"section":"","tags":null,"title":"À propos de moi","uri":"https://sim590.github.io/fr/a-propos/"},{"content":"  GSOC Comme j\u0026rsquo;ai mentionné dans au article antérieur, je participe au programme Google Summer Of Code grâce à l\u0026rsquo;organisation Debian qui supervise mes travaux contribuant au logiciel libre Ring.\nDeux jours restants Il reste deux jours avant mon départ pour le Cape, en Afrique du sud. C\u0026rsquo;est pour assister à l'événement debconf (« Debian conference »), organisé par Debian, que je me rends là. Cet événement est organisé à chaque année et, l\u0026rsquo;année prochaine, c\u0026rsquo;est à Montréal que ça aura lieu !  J\u0026rsquo;ai très hâte de vivre cette expérience qui sera sans doute innoubliable. Debian est une organisation pionière du monde du logiciel libre. Je rencontrerai des gens très dévoués et partageant avec moi beaucoup d\u0026rsquo;intérêts pour le logiciel libre et sa philosophie.\nL\u0026rsquo;Afrique du sud Ce sera la première fois que je prendrai l\u0026rsquo;avion et je ferai une escale à Amsterdam, une ville que j\u0026rsquo;aimerais bien visiter un jour. Ahhhh Jacques Brel.\nJe suis très heureux que le continent d\u0026rsquo;Afrique soit la première destination me permettant de sortir du continent d\u0026rsquo;Amérique pour la première fois. J\u0026rsquo;ai bien hâte de vivre l\u0026rsquo;ambiance du Cape.\nLes requins Y parrait qu\u0026rsquo;y\u0026rsquo;a des requins au Cape.\n","description":"Je m'envole pour le Cape.","id":13,"section":"","tags":null,"title":"Adieu","uri":"https://sim590.github.io/fr/adieu/"},{"content":"Par courriel (sim.desaulniers@gmail.com) ou via LinkedIn.\nL\u0026rsquo;empreinte de ma clef PGP:\n70B9 F71B 74C9 553D 01A1 A0EF 824A 8B97 F97E 4B08  Sinon, vous pouvez simplement utiliser le formulaire suivant:\n","description":"Informations pour me contacter","id":14,"section":"","tags":null,"title":"Contactez-moi","uri":"https://sim590.github.io/fr/contactez-moi/"}]
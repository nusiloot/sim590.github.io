[{"content":" L\u0026rsquo;approche de programmation dynamique est souvent associée au remplissage d\u0026rsquo;un tableau à deux dimensions et à l'écriture explicite de ce procédé sous forme itérative. Dans un langage fonctionnel comme Haskell, on bénéficie de quelques avantages d\u0026rsquo;expressivité de haut niveau et de lisibilité qu\u0026rsquo;on ne retrouve pas autrement.\nDans cet article, je commence par explorer deux exemples triviaux de programmation dynamique. Ensuite, je passe sur un problème tout aussi accessible, mais dont l\u0026rsquo;achèvement optimal demandera l\u0026rsquo;utilisation d\u0026rsquo;une structure Data.Array plutôt que la liste conventionnelle.\nÉvaluation paresseuse La particularité principale d\u0026rsquo;Haskell est qu\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;un langage paresseux, c\u0026rsquo;est-à-dire que l'évaluation d\u0026rsquo;une expression ou d\u0026rsquo;une valeur est faite de manière paresseuse. Plus précisément, on peut formuler ce concept par la propriété d\u0026rsquo;un langage à garantir l'évaluation de la valeur d\u0026rsquo;une expression donnée que si celle-ci est bien nécessaire à un calcul subséquent. Par exemple, considérons l\u0026rsquo;expression repeat 0. Cette expression correspond à une liste de taille virtuellement infinie. Cependant, head (repeat 0) correspond à une valeur de taille finie, en l\u0026rsquo;occurence 0. Comme Haskell est paresseux, il ne tente d'évaluer repeat 0 « complètement » que si c\u0026rsquo;est ce qui lui est demandé. Or, en passant repeat 0 en argument à head, on indique à Haskell qu\u0026rsquo;on n\u0026rsquo;est intéressé que par le premier élément, alors la liste repeat 0 ne sera jamais générée au complet, mais seul le premier élément sera calculé.\nDiviser pour régner et calculs en double Lorsqu\u0026rsquo;on souhaite résoudre un problème complexe, il est commun d\u0026rsquo;employer une approche où on réduit un problème à des sous-problèmes permettant ainsi de converger éventuellement en une solution finale. Cette approche s\u0026rsquo;appelle « diviser pour régner » et permet l'écriture de solutions élégantes (voir l\u0026rsquo;algorithme de tri fusion).\nL\u0026rsquo;indicateur premier de la pertinence d\u0026rsquo;investiguer pour une approche de programmation dynamique est celui de l\u0026rsquo;occurrence de calculs faits en double. Comme la méthode « diviser pour régner », l\u0026rsquo;approche de programmation dynamique se base sur un principe de division d\u0026rsquo;un problème en sous-problèmes suivant le principe d\u0026rsquo;optimalité de Bellman:\n Une solution optimale à un problème s\u0026rsquo;obtient en combinant des solutions optimales à des sous-problèmes.\n En d\u0026rsquo;autres termes, pour que le principe s\u0026rsquo;applique, il est nécessaire que la combinaison des solutions aux sous-problèmes soit optimale, lorsque les solutions aux sous-problèmes sont elles-mêmes optimales.\nSuite de Fibonacci 1  import Numeric.Natural   Considérons le problème de déterminer le \\(n^{\\text{ème}}\\) terme de la suite de Fibonacci. La récurrence très connue, définie sur les entiers naturels, est la suivante:\n$$ f(n) = \\begin{cases} 0 \u0026amp; \\text{si}\\ n=0\\\\\n1 \u0026amp; \\text{si}\\ n=1\\\\\nf(n-1) + f(n-2) \u0026amp; \\text{sinon} \\end{cases} $$\nL'écriture de cette fonction, suivant cette relation, est évidente:\n1 2 3 4  fib :: Natural -\u0026gt; Natural fib 0 = 0 fib 1 = 1 fib n = fib (n-1) + fib (n-2)   Cet algorithme est cependant non optimal puisqu\u0026rsquo;il est facile de voir que celui-ci effectue plusieurs calculs en double. Par exemple, pour \\(f(5)\\) on doit calculer \\(f(3)\\) et \\(f(4) = f(2) + f(3)\\). On voit bien qu\u0026rsquo;au moment de calculer \\(f(4)\\), il serait pertinent de récupérer la valeur déjà calculée \\(f(3)\\) afin d'éviter de la recalculer. Malheureusement, l\u0026rsquo;algorithme décrit plus haut ne fait pas cela. Il vaut la peine de noter que plus la valeur de \\(n\\) est élevée, plus le nombre de redondance augmente, ce qui gonfle ainsi la gravité du problème.\nFibonacci: optimisation La programmation dynamique nous permet de régler ce problème. Par exemple, on pourrait écrire la chose suivante:\n1 2 3 4 5  mfib :: Int -\u0026gt; Natural mfib = (map fib [0..] !!) -- (ii) where fib 0 = 0 fib 1 = 1 fib n = mfib (n-2) + mfib (n-1) -- (i)   Le changement apporté au code plus haut devrait être analysé en plusieurs parties. Premièrement, on retrouve la définition de fib qui ressemble pas mal à la première écriture. Cependant, on remarque que la définition du cas général \\((i)\\) ne fait plus directement appel à fib, mais à mfib. Deuxièmement, on remarque que la définition principale de mfib \\((ii)\\) fait un appel à fib. On a donc deux fonctions s\u0026rsquo;appellant en chaîne, ce qui ferme la boucle d\u0026rsquo;appels:\n$$\\texttt{fib} \\rightarrow \\texttt{mfib} \\rightarrow \\texttt{fib} \\rightarrow \\dots$$\nAinsi, le tout correspond à une fonction récurisve convergeant vers les cas de base tout comme c'était le cas dans la première approche. Ceci dit, l\u0026rsquo;entrelacement entre mfib et fib forme justement la différence majeur entre les deux approches. En effet, mfib est défini comme l\u0026rsquo;accès (!!) au \\(n^{\\text{ème}}\\) élément de la liste\n1  map fib [0..] -- (ii)   Cette liste correspond bien sûr à la liste abstraite suivante:\n[fib 0, fib 1, fib 2, ...] \nNotons premièrement que la liste map fib [0..] est une expression correspondant à une liste infinie. Mais comme Haskell est un langage paresseux, seuls les éléments nécessaires au calcul demandé par l\u0026rsquo;appel initial de mfib seront calculés.\nRegardons de plus près ce qui se passe avec un exemple sur mfib 5. Premièrement, l\u0026rsquo;accès au \\(5^\\text{ème}\\) élément de la liste sera demandé, ce qui engendrera l\u0026rsquo;appel à fib 5 qui en retour correspond à mfib 3 et mfib 4. L\u0026rsquo;expression partielle correspondant au calcul demandé initialement est donc mfib 3 + mfib 4. Or, mfib 3 est le \\(3^\\text{ème}\\) élément de la liste \\((ii)\\). On déduit une chose similaire pour mfib 4.\nOn pourrait croire un instant qu\u0026rsquo;Haskell pourrait calculer mfib 3 une fois, le stocker dans le tableau et que, le moment venu, mfib 4 provoque le même calcul, mais il s\u0026rsquo;avère qu\u0026rsquo;Haskell partage la liste \\((ii)\\) entre les différents appels de fib. Ainsi, le premier fil d\u0026rsquo;exécution permettant de calculer fib 3 provoquera l\u0026rsquo;inscription de cette valeur dans la liste afin que les appels subséquents n\u0026rsquo;aient qu'à réutiliser la valeur dans la liste. Il s\u0026rsquo;agit là de la forme la plus évidente et intuitive de l'écriture de cet algorithme sous une approche de programmation dynamique. Autrement, il est possible aussi d'écrire une expression remplissant la même fonction en une ligne:\n1 2  fibs :: [Natural] fibs = 0 : 1 : zipWith (+) fibs (tail fibs)   Cett expression correspond bien sûr à la liste de tous les nombres de Fibonacci. Il suffit maintenant d\u0026rsquo;accéder à l'élément qu\u0026rsquo;on souhaite, par exemple le \\(5^\\text{ème}\\), avec fibs !! 5. Ici encore, on emploie une approche de programmation dynamique puisque la liste est progressivement construite en réutilisant les deux derniers éléments de la liste pour les additionner afin de former le prochain élément ad infinitum.\nNombres triangulaires 1  import Numeric.Natural   Considérons maintenant le problème de générer les nombres triangulaires. On sait que \\(t_n\\), le \\(n^{\\text{ème}}\\) nombre triangulaire, est donné par l\u0026rsquo;expression suivante:\n$$ t_n = \\sum_{i=1}^n i = 1 + 2 + \\dots + n$$\nUne première approche vient rapidement en tête:\n1 2  triangs :: [Natural] triangs = [sum [1..n] | n \u0026lt;- [1..]]   Cependant, cette première approche est absolument affreuse. On refait clairement plusieurs fois les mêmes calculs. On pourrait aussi tirer avantage du fait que \\(t_n\\) trouve l\u0026rsquo;expression équivalente suivante:\n$$ t_n = \\frac{n(n+1)}{2} $$\nAinsi, on pourrait alors écrire:\n1 2  triangs\u0026#39; :: [Natural] triangs\u0026#39; = [n * (n + 1) `div` 2 | n \u0026lt;- [1..]]   Bien que cette stratégie, reposant sur un astuce analytique, apporterait là une amélioration substantielle, cela ne ferait pas de cette approche une voie tout à fait optimale. En effet, on remarque qu\u0026rsquo;on effectue une multiplication, une division et une addition pour chaque élément généré. Il est possible de faire mieux en utilisant la programmation dynamique. De façon similaire à la dernière solution pour Fibonacci, on peut écrire:\n1 2  triangs\u0026#39;\u0026#39; :: [Natural] triangs\u0026#39;\u0026#39; = 1 : zipWith (+) triangs\u0026#39;\u0026#39; [2..]   Ici, on créé encore une fois une liste qui se joint à une seconde liste, la liste infinie [2..], par l\u0026rsquo;addition des éléments de chaque liste deux à deux. On peut développer l\u0026rsquo;expression comme suit:\n1 2 3  1 : zipWith (+) [1,...] [2,3,4...] correspond à [1, 3, ...] 1 : 3 : zipWith (+) [3,...] [3,4,5...] correspond à [1, 3, 6, ...] 1 : 3 : 6 : zipWith (+) [6,...] [4,5,6...] correspond à [1, 3, 6, 10, ...]   Évidemment, une méthode plus intuitive (mais plus verbeuse) est aussi possible.\nSéquences de Collatz 1 2  import Numeric.Natural import Data.Array   Bien que ce prochain problème n\u0026rsquo;est pas d\u0026rsquo;un ordre différent de difficulté, nous allons prendre une avenue qui diffère légèrement afin de garantir encore un rendement optimal.\nUne séquence de Collatz est une séquence de nombres générée suivant un nombre en entrée, appelons cet élément « racine ». Soit $g: \\mathbb{N} \\longrightarrow \\mathbb{N}$ définie comme:\n$$ g(m) = \\begin{cases} \\frac{m}{2} \u0026amp; \\text{si}\\ m\\ \\text{est pair}\\\\\n\\\\ % Nécessaire car autrement, l'équation n\u0026rsquo;arrive pas à se dessiner (trop serré) 3n + 1 \u0026amp; \\text{sinon} \\end{cases} $$\nUne séquence de Collatz, pour une racine \\(r\\), est définie comme la suite\n$$(g(r), (g \\circ g)(r), (g \\circ g \\circ g)(r), \\dots, 1).$$\noù \\(\\circ\\) représente la composition de fonction.\nProblème Pour \\(n \\in \\mathbb{N}\\), on souhaite déterminer la taille de la plus longue séquence de Collatz pour tout \\(1 \\le r \\le n\\).\nUne approche naïve pourrait ressembler à la suivante. Définissons premièrement une fonction calculant la prochaine valeur de la séquence. Appelons la step:\n1 2 3 4 5  step :: Natural -\u0026gt; Natural step 1 = 1 step m | even m = m `div` 2 | otherwise = (3 * m + 1) `div` 2   Remarquons que le cas où \\(m\\) est impair n\u0026rsquo;est plus \\(3m+1\\), mais maintenant \\(\\frac{(3m+1)}{2}\\). Ceci est possible sans perte de généralité puisque si \\(m\\) est impair, alors \\(m=2k+1\\) pour \\(k\\in\\mathbb{N}\\). Ainsi,\n$$ 3m+1 = 3(2k+1)+1 = 2(3k +2) \\quad \\text{est pair}. $$\nCe faisant, le traitement où l\u0026rsquo;argument de step est pair peut tout de suite s\u0026rsquo;appliquer sur l\u0026rsquo;image de \\(3m+1\\). On sauve ainsi une étape à chaque nombre impair rencontré.\nEnsuite, l\u0026rsquo;algorithme bête pour déterminer la longueur d\u0026rsquo;une séquence de Collatz avec pour racine m pourrait ressembler au suivant.\n1 2  dumbSeq :: Natural -\u0026gt; Int dumbSeq m = (+1) $ length $ takeWhile (/=1) $ iterate step m   La lecture est assez directe. On itère sur les appels successifs de step avec comme premier argument m jusqu'à ce qu\u0026rsquo;on tombe sur 1. Ici, iterate créé la liste de tous les résultats d\u0026rsquo;applicaiton de step. On n\u0026rsquo;a donc qu'à prendre la taille de cette liste et additionner 1 (pour compter le nombre 1). Afin de calculer la valeur maximale pour \\(1 \\le r \\le \\text{n}\\), on peut alors calculer comme suit:\n1 2 3  maxDumb :: Natural -\u0026gt; Natural maxDumb 1 = 0 maxDumb n = snd $ maximum $ map (\\ m -\u0026gt; (dumbSeq m, m)) [1..n]   Ici, on créé une liste de paires ordonnées \\((g^i(m), m)\\). On trouve le maximum de cette liste en comparant le premier élément de chaque paire ordonnée (le comportement par défaut de compare tel que défini pour l\u0026rsquo;instance (,) a de la classe Ord).\nClairement, pour \\(n\\) suffisamment grand, le problème peut devenir couteux en temps. On remarque bien sûr que certaines séquences se croisent. Par exemple:\n1 2  r = 3 =\u0026gt; g(3) = g(5) = g(8) = g(4) = g(2) = 1 r = 4 =\u0026gt; g(4) = g(2) = 1   Ce faisant, si on avait à calculer la longueur de la séquence pour \\(g(3)\\) avant \\(g(4)\\), alors le calcul à l\u0026rsquo;itération \\(r=4\\) serait gratuit si nous employions une approche de programmation dynamique.\nSupposons qu\u0026rsquo;on soit intéressé à trouver la réponse pour \\(n\\) très grand. Il serait d\u0026rsquo;abord nécessaire de fixer une taille maximale pour l\u0026rsquo;antémémoire utilisée pour stocker les valeurs déjà calculées. Disons que \\(10^6\\) est raisonnable:\n1 2  bigN :: Natural bigN = 10 ^ (6 :: Natural)   Ensuite, nous définissons la structure seqArray servant d\u0026rsquo;antémémoire ainsi que la routine de comptage des itérations seq' à travers step:\n1 2 3 4 5 6 7 8 9 10  seq\u0026#39; :: Natural -\u0026gt; Natural seq\u0026#39; 1 = 1 seq\u0026#39; i = 1 + next where i\u0026#39; = step i next | i\u0026#39; \u0026gt; bigN = seq\u0026#39; i\u0026#39; | otherwise = seqArray ! i\u0026#39; seqArray :: Array Natural Natural seqArray = listArray bounds\u0026#39; [ seq\u0026#39; i | i \u0026lt;- range bounds\u0026#39;] where bounds\u0026#39; = (1, bigN)   Nous avons grandement avantage ici à utiliser un tableau permettant un accès \\(\\mathcal{O}(1)\\) pour chaque valeur. Bien que c'était autant le cas pour les deux problèmes précédents, nous n\u0026rsquo;avons pas introduit l\u0026rsquo;utilisation de Data.Array jusqu\u0026rsquo;ici afin de simplifier les choses.\nFonctionnement Comme précédemment, remarquons la liaison entre seq' et seqArray. On voit bien que seq' est défini en fonction de seqArray et vice versa. D\u0026rsquo;un côté, on peut le voir comme le fait que seq' utilise les valeurs inscrites dans le tableau afin de faire ses calculs. De l\u0026rsquo;autre côté, on peut interpréter que seqArray n\u0026rsquo;est défini que pour les valeurs que seq' prend. Il y a là une différence majeur avec l'écriture dans un langage impératif comme ceux s\u0026rsquo;apparentant au langage C, par exemple.\nIl n\u0026rsquo;y a aucune exigence à l\u0026rsquo;endroit du programmeur à déterminer les indices admissibles pour indexation dans le tableau. La paresse d\u0026rsquo;Haskell s\u0026rsquo;occupe de tout.\nSéquence de taille maximale Finalement, la fonction suivante évalue la taille maximale d\u0026rsquo;une séquence pour une racine \\(1 \\le r \\le \\texttt{n}\\).\n1 2 3 4  maxSeq :: Natural -\u0026gt; Natural maxSeq 1 = 0 maxSeq n = l where (_, l) = maximum $ map swap $ genericTake n $ assocs seqArray   ","description":"","id":7,"section":"haskell","tags":["Séquence de Collatz","Data.Array","nombre triangulaire"],"title":"Haskell: programmation dynamique","uri":"https://sim590.github.io/haskell/programmation-dynamique/"},{"content":"Je m\u0026rsquo;appelle Simon Désaulniers. Je suis une personne qui œuvre dans mon quotidien en mathématiques et informatique. Je m\u0026rsquo;intéresse à plusieurs sujets comme:\n l\u0026rsquo;algorithmique; les langages informatiques; la sécurité informatique et la cryptographie; les logiciels et outils informatiques; les systèmes distribués; le logiciel libre et respectueux de la vie privée; l\u0026rsquo;algèbre; etc.  Mes intérêts dépassent bien sûr l\u0026rsquo;informatique et les mathématiques. J\u0026rsquo;aime particulièrement les langues, la culture, la musique, la politique et les jeux vidéo.\nLe contenu de mon site Sur ce site, j\u0026rsquo;expose différents concepts, notions ou pratiques sur différents sujets. J\u0026rsquo;aime partager mes découvertes, résolutions de problème et analyses. J\u0026rsquo;espère ainsi permettre à plusieurs d\u0026rsquo;y tirer quelque chose d\u0026rsquo;utile ou du moins intéressant. Je suis un utilisateur de logiciels libres et en particulier de GNU/Linux depuis 2012. Il se peut donc que des sujets en lien avec cela soient exploités.\n","description":"","id":8,"section":"","tags":null,"title":"À propos de moi","uri":"https://sim590.github.io/a-propos/"},{"content":"  GSOC Comme j\u0026rsquo;ai mentionné dans au article antérieur, je participe au programme Google Summer Of Code grâce à l\u0026rsquo;organisation Debian qui supervise mes travaux contribuant au logiciel libre Ring.\nDeux jours restants Il reste deux jours avant mon départ pour le Cape, en Afrique du sud. C\u0026rsquo;est pour assister à l'événement debconf (« Debian conference »), organisé par Debian, que je me rends là. Cet événement est organisé à chaque année et, l\u0026rsquo;année prochaine, c\u0026rsquo;est à Montréal que ça aura lieu !  J\u0026rsquo;ai très hâte de vivre cette expérience qui sera sans doute innoubliable. Debian est une organisation pionière du monde du logiciel libre. Je rencontrerai des gens très dévoués et partageant avec moi beaucoup d\u0026rsquo;intérêts pour le logiciel libre et sa philosophie.\nL\u0026rsquo;Afrique du sud Ce sera la première fois que je prendrai l\u0026rsquo;avion et je ferai une escale à Amsterdam, une ville que j\u0026rsquo;aimerais bien visiter un jour. Ahhhh Jacques Brel.\nJe suis très heureux que le continent d\u0026rsquo;Afrique soit la première destination me permettant de sortir du continent d\u0026rsquo;Amérique pour la première fois. J\u0026rsquo;ai bien hâte de vivre l\u0026rsquo;ambiance du Cape.\nLes requins Y parrait qu\u0026rsquo;y\u0026rsquo;a des requins au Cape.\n","description":"Je m'envole pour le Cape.","id":11,"section":"","tags":null,"title":"Adieu","uri":"https://sim590.github.io/adieu/"},{"content":"Par courriel (sim.desaulniers@gmail.com) ou via LinkedIn.\nL\u0026rsquo;empreinte de ma clef PGP:\n70B9 F71B 74C9 553D 01A1 A0EF 824A 8B97 F97E 4B08  Sinon, vous pouvez simplement utiliser le formulaire suivant:\n","description":"Informations pour me contacter","id":12,"section":"","tags":null,"title":"Contactez-moi","uri":"https://sim590.github.io/contactez-moi/"}]